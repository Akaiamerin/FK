## 参考教材：[操作系统――精髓与设计原理（第九版）](https://book.douban.com/subject/35171480)
1.1　列出并简要定义计算机的 4 个主要组成部分。

处理器：控制计算机的操作，执行数据处理功能。

内存：存储数据和程序。

输入/输出模块：在计算机和外部环境之间移动数据。

系统总线：在处理器、内存和输入/输出模块间提供通信的设施。

<br/>

1.2　定义处理器寄存器的两种主要类别。

内存地址寄存器：确定下次读/写的存储器地址。

内存缓冲寄存器：存放要写入存储器的数据或从存储器中读取的数据。

<br/>

1.3　一般而言，一条机器指令能指定的 4 种不同操作是什么？

处理器 - 存储器：数据可以从处理器传送到存储器，或从存储器传送到处理器。

处理器 - I/O：通过处理器和 I/O 模块间的数据传送，数据可以输出到外部设备，或从外部设备向处理器输入数据。

数据处理：处理器可以执行很多与数据相关的算术操作或逻辑操作。

控制：某些指令可以改变顺序。

<br/>

1.4　什么是中断？

允许其他模块（I/O、存储器）中断处理器正常处理过程的机制。

<br/>

1.5　多个中断的处理方式是什么？

处理多个中断有两种方法。

第一种方法是正在处理一个中断时，禁止再发生中断。若在此期间发生了中断，则通常中断保持挂起，当处理器再次允许中断时，再由处理器检查。

第二种方法是定义中断优先级，允许高优先级中断打断低优先级中断的运行。

<br/>

1.6　内存层次各个元素间的特征是什么？

存取时间越快，每“位”价格越高。

容量越大，每“位”的价格越低。

容量越大，存取速度越慢。

<br/>

1.7　什么是高速缓存？

处理器和内存之间提供一个容量小且速度快的存储器。

<br/>

1.8　多处理器系统和多核系统的区别是什么？

多处理器系统：一条系统总线上有多个处理器。

多核系统：两个或多个处理器组装在同一块硅上。

<br/>

1.9　空间局部性和时间局部性之间的区别是什么？

空间局部性指涉及多簇存储器单元的执行趋势，反映了处理器顺序访问指令的趋势，也反映了程序顺序访问数据单元的趋势，如处理数据表。

时间局部性指处理器访问最近使用过的存储器单元的趋势，例如在执行一个循环时，处理器重复执行相同的指令集合。

<br/>

1.10　开发空间局部性和时间局部性的策略是什么？

空间局部性通常是使用较大的高速缓存并将预取机制集成到高速缓存控制逻辑中实现的。

时间局部性是通过将近来使用的指令和数据值保存到高速缓存中并使用高速缓存的层次结构实现的。

<br/>

2.1　操作系统设计的三个目标是什么？

方便：操作系统使计算机更易于使用。

有效：操作系统允许以更有效的方式使用计算机系统资源。

扩展的能力：在构造操作系统时，应该允许在不妨碍服务的前提下，有效地开发、测试和引入新的系统功能。

<br/>

2.2　什么是操作系统的内核？

内核程序包含操作系统中最常用的功能。

<br/>

2.3　什么是多道程序设计？

内存空间容得下操作系统和两个用户程序，则当一个作业需要 I/O 时，处理器可以切换到另一个可能并不在等待 I/O 的作业。进一步还可以扩展内存以保存三个、四个程序或更多的程序，且在它们之间进行切换。

<br/>

2.4　什么是进程？

一个正在执行的程序。

计算机中正在运行的程序的一个实例。

可分配给处理器并由处理器执行的一个实体。

由一个单一顺序线程、一个当前状态和一组相关系统资源所表征的活动单元。

<br/>

2.5　操作系统是怎样使用进程上下文的？

操作系统给每个进程（包含程序、数据和上下文信息）分配了一块内存区域，并且在由操作系统建立和维护的进程表中进行了记录。进程表包含记录每个进程的表项，表项内容包括指向包含进程的存储块地址的指针，还包括该进程的部分或全部执行上下文。执行上下文的其余部分存放在别处，可能和进程本身保存在一起，通常还可能保存在内存的一块独立区域中。进程索引寄存器包含当前正在控制处理器的进程在进程表中的索引。程序计数器指向该进程中下一条待执行的指令。基址寄存器和界限寄存器定义该进程所占据的存储器区域：基址寄存器中保存该存储器区域的开始地址，界限寄存器中保存该区域的大小（以字节或字为单位）。程序计数器和所有数据引用相对于基址寄存器来解释，且不能超过界限寄存器中的值，因此可以保护内部进程间不会相互干涉。

<br/>

2.6　列出并简要介绍操作系统的 5 种典型存储管理职责。

进程隔离：操作系统必须保护独立的进程，防止互相干扰各自的存储空间，包括数据和指令。

自动分配和管理：程序应该根据需要在存储层次见动态地分配，分配对程序员是透明的。因此，程序员无须关心与存储限制有关的问题，操作系统会有效地实现分配问题，可仅在需要时才给作业分配存储空间。

支持模块化程序设计：程序员应该能够定义程序模块，并动态地创建、销毁模块和改变模块的大小。

保护和访问控制：不论在存储层次中的哪一级，存储器的共享都会产生一个程序访问另一个程序内存空间的潜在可能性。当某个特定的应用程序需要共享时，这是可取的。但在其他时候，它可能会威胁到程序的完整性，甚至威胁到操作系统自身。操作系统必须允许一部分内存可以由各种用户以各种方式进行访问。

长期存储：许多应用程序需要在计算机关机后长时间地保存信息。

<br/>

2.7　实地址和虚地址的区别是什么？

程序通过虚地址访问字，虚地址由页号和页中的偏移量组成。进程的每页都可置于内存中的任何地方，分页系统提供了程序中使用的虚地址和内存中的实地址或物理地址之间的动态映射。

<br/>

2.8　描述时间片轮转调度技术。

操作系统维护了多个队列，每个队列代表等待某些资源的进程列表。短程队列由在内存中（或至少最基本的部分在内存中）并等待处理器可用时随时准备运行的进程组成。任何一个这样的进程都可在下一步使用处理器，但究竟选择哪个进程则取决于短期调度其或分排器。常用的一种策略是，依次给队列中的每个进程分配一定时间，这称为时间片轮转技术，时间片轮转技术使用了一个环形队列。

<br/>

2.9　解释单体内核和微内核的区别。

单体内核，操作系统应提供的多数功能都由这个大内核来提供，包括调度、文件系统、网络、设备驱动器、内存管理等。典型情况下，这个大内核是作为一个进程实现的，所有元素都共享同一地址空间。

微内核体系结构只给内核分配一些最基本的功能，包括地址空间管理、进程间通信和基本的调度。其它操作系统服务则由运行在用户模式且与其他应用程序类似的进程提供，这些进程可根据特定的应用和环境需求进行定制，有时也称这些进程为服务器。

<br/>

2.10　什么是多线程？

多线程技术是指执行一个应用程序的进程划分为可以同时运行的多个线程。

<br/>

2.11　列出对称多处理操作系统设计时要考虑的关键问题。

并发进程或线程：内核程序应可重入，以使多个处理器能同时执行同一段内核代码。当多个处理器执行内核的相同或不同部分时，为避免数据损坏和无效操作，需要妥善管理内核表和数据结构。

调度：任何一个处理器都可以执行调度，这既增加了执行调度策略的复杂度，又增加了保证调度相关数据结构不被损坏的复杂度。若使用的是内核级多线程方式，则存在将同一进程的多个线程同时调度在多个处理器上的可能性。

同步：因为可能会存在多个活跃进程访问共享地址空间或共享 I/O 资源的情况，因此必须认真考虑如何提供有效的同步机制这一问题。同步用来实现互斥及事件排序。

内存管理：多处理器上的内存管理要处理单处理器上内存管理涉及的所有问题。另外，操作系统还要充分利用硬件提供的并行性来实现最优性能。不同处理器上的分页机制必须进行调整，以实现多处理器共享页或段时的数据一致性，执行页面置换。物理页的重用是我们关注的最大问题，即必须保证物理页在重新使用前不能访问到它以前的内容。

可靠性和容错性：出现处理器故障时，操作系统应能妥善地降低故障的影响。调度器和操作系统的其他部分必须能识别出发生故障的处理器，并重新组织管理表。

<br/>

3.1　什么是指令跟踪？

列出为进程执行的指令序列，可描述单个进程的行为。

<br/>

3.2　那些常见事件会触发进程的创建？

新的批处理作业。磁带或磁盘中的批处理作业控制流通常会提供给操作系统。当操作系统准备接收新工作时，将读取下一个作业控制命令。

交互登录。终端用户登录到系统。

未提供服务而由操作系统创建。操作系统可以创建一个进程，代表用户程序执行一个功能，使用户无须等待（如控制打印的进程）。

由现有进程派生。基于模块化的考虑或开发并行性，用户程序可以指示创建多个进程。

<br/>

3.3　简要定义图 3.6 所示进程模型中的每种状态。

运行态：进程正在运行。

就绪态：进程做好了准备，只要有机会就开始运行。

阻塞/等待态：进程在某些事件发生前不能执行，如 I/O 操作完成。

新建态：刚刚创建的进程，操作系统还未把它加入可执行进程组，它通常是进程控制块已经创建但还未加载到内存中的新进程。

退出态：操作系统从可执行进程组中释放出的进程，要么它自身已停止，要么它因某种原因被取消。

<br/>

3.4　抢占一个进程是什么意思？

假设进程 A 以一个给定的优先级运行，而具有更高优先级的进程 B 正处于阻塞态。若操作系统知道进程 B 等待的事件已发生，则将进程 B 转换到就绪态，然后因为优先级的原因中断进程 A 的执行，将处理器分派给进程 B，此时我们说操作系统抢占了进程 A。一般来说，抢占定义为收回一个进程正在使用的资源。此时，资源就是处理器本身。进程正在执行并且可以继续执行，但由于其他进程需要执行而被抢占。

<br/>

3.5　什么是交换，其目的是什么？

交换即把内存中某个进程的一部分或全部移到磁盘中。当内存中不存在就绪态的进程时，操作系统就把被阻塞的进程换出到磁盘中的挂起队列，即临时从内存中“提出”的进程队列。操作系统此后要么从挂起队列中取出另一个进程，要么接受另一个新进程的请求，将其放入内存运行。

<br/>

3.6　为何图 3.9(b) 中有两个阻塞态？

若没有就绪进程，则至少换出一个阻塞进程，以便为另一个未阻塞进程腾出空间。即使有可用的就绪态进程，也能完成这种转换。若操作系统需要确定当前正运行的进程，或就绪进程为了维护基本的性能而需要更多的内存空间，则会挂起一个阻塞的进程。

<br/>

3.7　列出挂起态进程的 4 个特点。

该进程不能立即执行。

该进程可能在也可能不在等待一个事件。若在等待一个事件，那么阻塞条件不依赖于挂起条件，阻塞事件的发生不会使进程立即执行。

为阻止该进程执行，可通过代理使其置于挂起态，代理可以是进程本身，也可以是父进程或操作系统。

除非代理显式地命令系统进行状态转换，否则该进程无法从这一状态转移。

<br/>

3.8　操作系统会为哪类实体维护信息表？

内存、I/O、文件、进程

<br/>

3.9　列出进程控制块中的三类信息。

进程标识信息

进程状态信息

进程控制信息

<br/>

3.10　为什么需要两种模式（用户模式和内核模式）？

保护操作系统和重要的操作系统表（如进程控制块）不受用户程序的干扰。

<br/>

3.11　操作系统创建一个新进程的步骤是什么？

为新进程分配一个唯一的进程标识符。此时，主进程表中会添加一个新表项，每个进程一个表项。

为进程分配空间。这包括进程映像中的所有元素。因此，操作系统必须知道私有用户地址空间（程序和数据）和用户栈需要多少空间。默认情况下会根据进程的类型分配这些值，但也可在作业创建时基于用户请求设置这些值。若一个进程由另一个进程生成，则父进程可把所需的值作为进程创建请求的一部分传递给操作系统。若任何已有的地址空间将被这个新进程共享，则需要建立正确的链接。最后，必须为进程控制块分配空间。

初始化进程控制块。进程标识部分包括进程 ID 和其他相关的 ID，如父进程的 ID 等；处理器状态信息部分的多数项目通常初始化为 0，但程序计数器（置为程序入口点）和系统栈指针（定义进程栈边界）除外。进程控制信息部分根据标准的默认值和该进程请求的特性来初始化。例如，进程状态通常初始化为就绪或就绪/挂起。优先级默认情况下可设置为最低，除非显式请求了更高的优先级；进程最初不拥有任何资源（I/O 设备、文件），除非显式地请求了这些资源，或继承了父进程的资源。
设置正确的链接。例如，若操作系统将每个调度队列都维护为一个链表，则新进程必须放在就绪或就绪/挂起链表中。

创建或扩充其他数据结构。例如，操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件。

<br/>

3.12　中断和陷阱有何区别？

中断与当前正运行进程无关的某种外部事件相关，如完成一次 I/O 操作。

陷阱与当前正运行进程产生的错误或异常条件相关，如非法的文件访问。

<br/>

3.13　举出中断的三个例子。

时钟中断：操作系统确定当前正运行进程的执行时间是否已超过最大允许时间段［时间片，即进程中断前可以执行的最大时间段］。若超过，进程就切换到就绪态，并调入另一个进程。

I/O 中断：操作系统确定是否已发生 I/O 活动。若 I/O 活动是一个或多个进程正在等待的事件，则操作系统就把所有处于阻塞态的进程转换为就绪态（阻塞/挂起态进程转换为就绪/挂起态）。操作系统必须决定是继续执行当前处于运行态的进程，还是让具有高优先级的就绪态进程抢占这个进程。

内存失效：处理器遇到一个引用不在内存中的字的虚存地址时，操作系统就必须从外存中把包含这一引用的内存块（页或段）调入内存。发出调入内存块的 I/O 请求后，内存失效进程将进入阻塞态；操作系统然后切换进程，恢复另一个进程的执行。期望的块调入内存后，该进程置为就绪态。

<br/>

3.14　模式切换和进程切换有何区别？

模式切换可在不改变运行态进程的状态下出现。

<br/>

4.1　表 3.5 列出了无线程操作系统中进程控制块的基本元素。对于多线程系统，这些元素中的哪些可能属于线程控制块，哪些可能属于进程控制块？

处理器状态信息属于线程控制块。

进程标识信息、进程控制信息属于进程控制块。

<br/>

4.2　请给出线程间的状态切换比进程间的状态切换开销更低的原因。

在已有进程中创建一个新线程的时间，远少于创建一个全新进程的时间。

终止线程要比终止进程所花的时间少。

统一进程内线程间切换的时间，要少于进程间切换的时间。

线程提高了不同程序间通信的效率。在多数操作系统中，独立进程间的通信需要内核介入，以提供保护和通信所需的机制。但是，由于同一进程中的多个线程共享内存和文件，因此它们无需调用内核就可互相通信。

<br/>

4.3　线程中两个独立无关的特点是什么？

资源所有权：进程包括存放进程映像的虚拟地址空间。进程总具有对资源的控制权或所有权，这些资源包括内存、I/O 通道、I/O 设备和文件等。操作系统提供预防进程间发生不必要资源冲突的保护功能。

调度/执行：进程执行时采用一个或多程序的执行路径（轨迹），不同进程的执行过程会交替进行。因此，进程具有执行态（运行、就绪等）和分配给其的优先级，是可被操作系统调度和分派的实体。

<br/>

4.4　给出在单用户多处理系统中使用线程的 4 个例子。

前台和后台工作：例如，在电子表格程序中，一个线程可以显示菜单并读取用户输入，而另一个线程执行用户命令并更新电子表格。这种方案允许程序在前一条命令完成前提示输入下一条命令，因而通常会使用户感到应用程序的响应速度有所提高。

异步处理：程序中的异步元素可用线程来实现。例如，为避免掉电带来的损失，往往把文字处理程序设计成每隔 1 分钟就把随机存储内存缓冲区中的数据写入磁盘。可以创建一个任务是周期性地进行备份的线程，该线程由操作系统直接调度。这样，主程序中就不需要特别的代码来提供时间检查或协调输入和输出。

执行速度：多线程进程在计算一批数据时，可通过设备读取下一批数据。在多处理器系统中，同一进程中的多个线程可同时执行。这样，即使一个线程在读取数据时被 I/O 操作阻塞，另一个线程仍然可以继续执行。

模块化程序结构：涉及多种活动或多种输入/输出源和目的的程序，更容易使用线程来设计和实现。

<br/>

4.5　哪些资源通常被一个进程中的所有线程共享？

一个进程中的所有线程共享同一个地址空间和诸如打开的文件之类的其他资源。

<br/>

4.6　列出用户级线程相对于内核线程的三个优点。

所有线程管理数据结构都在一个进程的用户地址空间中，线程切换不需要内核模式特权，因此进程不需要为了管理线程而切换到内核模式，进而节省了两次状态转换（从用户模式到内核模式，以及从内核模式返回用户模式）的开销。

调度因应用程序的不同而不同。一个应用程序可能更适合简单的轮转调度算法，而另一个应用程序可能更适合基于优先级的调度算法。为了不要乱底层的操作系统调度程序，可以做到为应用程序量身定做调度算法。

ULT 可在任何操作系统中运行，不需要对底层内核进行修改以支持 ULT。线程库是供所有应用程序共享的应用级函数。

<br/>

4.7　列出用户级线程相对于内核级线程的两个缺点。

在典型的操作系统中，许多系统调用都会引起阻塞。因此，在 ULT 执行一个系统调用时，不仅会阻塞这个线程，也会阻塞进程中的所有线程。

在纯 ULT 策略中，多线程应用程序不能利用多处理技术。内核一次只把一个进程分配给一个处理器，因此一个进程中只有一个线程可以执行，这相当于在一个进程内实现了应用级多道程序设计。虽然多道程序设计可明显提高应用程序的速度，但同时执行部分代码更会使某些应用程序受益。

<br/>

4.8　定义“套管”技术。

把一个产生阻塞的系统调用转化为一个非阻塞的系统调用。

<br/>

5.1　列出与并发相关的 4 个设计问题。

进程间通信、资源共享与竞争（如内存、文件、I/O 访问）、多个进程活动的同步以及给进程分配处理器时间等。

<br/>

5.2　产生并发 3 种上下文是什么？

多应用程序： 多道程序设计技术允许在多个活动的应用程序间动态共享处理器时间。

结构化应用程序： 作为模块化设计和结构化程序设计的扩展，一些应用程序可被有效地设计成一组并发进程。

操作系统结构： 同样的结构化程序设计优点适用于系统程序，且我们已知操作系统自身常常作为一组进程或线程实现。

<br/>

5.3　执行并发进程的最基本要求是什么？

加强互斥的能力。

<br/>

5.4　列出进程间的三种互相知道的程度，并简要给出各自的定义。

进程之间相互不知道对方的存在： 这是一些独立的进程，它们不会一起工作。关于这种情况的最好例子是多个独立进程的多道程序设计，可以是批处理作业，也可以是交互式会话，或者是两者的混合。尽管这些进程不会一起工作，但操作系统需要知道它们对资源的竞争情况。例如，两个无关的应用程序可能都想访问同一个磁盘、文件或打印机。操作系统必须控制对它们的访问。

进程间接知道对方的存在： 这些进程并不需要知道对方的进程 ID，但它们共享某些对象，如一个 I/O 缓冲区。这类进程在共享同一个对象时会表现出合作行为。

进程直接知道对方的存在： 这些进程可通过进程 ID 互相通信，以合作完成某些活动。同样，这类进程表现出合作行为。

<br/>

5.5　竞争进程和合作进程间有何区别？

竞争进程需要同时访问相同的资源，像磁盘，文件或打印机。

合作进程要么共享访问一个共有的资源，像一个内存访问区，要么就与其他进程相互通信，在一些应用程序或活动上进行合作。

<br/>

5.6　列出与竞争相关的三个控制问题，并简要给出各自的定义。

互斥：当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情形。

死锁：两个或两个以上的进程因每个进程都在等待其他进程做完某些事情而不能继续执行的情形。

饥饿：一个可运行进程尽管能继续执行，但被调度程序无限期地忽略而不能被调度执行的情形。

<br/>

5.7　列出对互斥的要求。

必须强制实施互斥：在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。

一个在非临界区停止的进程不能干涉其他进程。

绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会出现死锁或饥饿。

没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。

对相关进程的执行速度和处理器的数量没有任何要求和限制。

一个进程驻留在临界区中的时间必须是有限的。

<br/>

5.8　在信号量上可以执行什么操作？

一个信号量可以初始化成非负数。

semWait 操作使信号量减 1。若值变成负数，则阻塞执行 semWait 的进程，否则进程继续执行。

semSignal 操作使信号量加 1。若值小于等于零，则被 senWait 操作阻塞的进程解除阻塞。

<br/>

5.9　二元信号量和一般信号量有何区别？

二元信号量可以初始化为 0 或 1。

semWaitB 操作检查信号的值。若值为 0，则进程执行 semWaitB 就会受阻。若值为 1，则将值改为 0，并继续执行该进程。

semSignalB 操作检查是否有任何进程在该信号上受阻。若有进程受阻，则通过 semWaitB 操作，受阻的进程会被唤醒；若没有进程受阻，则值设置为 1。

<br/>

5.10　强信号量和弱信号量有何区别？

采用先进先出策略定义的信号量称为强信号量。

而没有规定进程从队列中移出顺序的信号量称为弱信号量。

<br/>

5.11　什么是管程？

管程是有一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：

局部数据变量只能被管程的过程访问，任何外部过程都不能访问。

一个进程通过调用管程的一个过程进入管程。

在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。

<br/>

5.12　关于消息，阻塞和无阻塞有何区别？

阻塞 send，阻塞 receive：发送者和接收者都被阻塞，直到完成信息的投递。这种情况有时也称为会和，它考虑到了进程间的紧密同步。

无阻塞 send，阻塞 receive：尽管发送者可以继续，但接收者会被阻塞直到请求的消息到达。这可能是最有用的一种组合，它允许一个进程给各个目标进程尽快地发送一条或多条消息。在继续工作前必须接收到消息的进程将被阻塞，知道该消息到达。例如，一个服务器进程给其他进程提供服务或资源。

无阻塞 send，无阻塞 receive：不要求任何一方等待。

<br/>

5.13　与读者/写者问题相关的条件通常有哪些？

任意数量的读进程可同时读这个文件。

一次只有一个写进程可以写文件。

若一个写进程正在写文件，则禁止任何读进程读文件。

<br/>

6.1　给出可重用资源和可消耗资源的例子。

可重用资源的例子包括处理器、I/O 通道、内存和外存、设备，以及数据结构（诸如文件、数据库和信号量）。

可消耗资源的例子有中断、信号、消息和 I/O 缓冲区中的信息。

<br/>

6.2　产生死锁的三个必要条件是什么？

互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。

占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。

不可抢占。不能强行抢占进程已占有的资源。

<br/>

6.3　产生死锁的 4 个条件是什么？

互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。

占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。

不可抢占。不能强行抢占进程已占有的资源。

循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。

<br/>

6.4　如何防止占有且等待条件？

可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。

<br/>

6.5　给出防止不可抢占条件的两种方法。

首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。

<br/>

6.6　如何防止循环等待条件？

循环等待条件可通过定义资源类型的线性顺序来预防。

<br/>

6.7　死锁避免、检查和预防之间的区别是什么？

死锁避免：允许三个必要条件，但通过明智地选择，可确保永远不会到达死锁点。

死锁检查：只要有可能，就会给进程分配其所请求的资源。操作系统周期性地执行一个算法来检测前面的条件。

死锁预防：通过防止发生三个必要条件中的一个（互斥、占有且等待、非抢占）间接完成，也可通过防止循环等待直接完成，但都会导致低效的资源使用和低效的进程执行。

<br/>

7.1　内存管理需要满足哪些需求？

重定位、保护、共享、逻辑组织、物理组织。

<br/>

7.2　为何需要重定位进程的能力？

在多道程序设计系统中，可用的内存空间通常被多个进程共享。通常情况下，程序员事先并不知道在某个程序执行期间会有其他哪些程序驻留在内存中。此外，我们还希望提供一个巨大的就绪进程池，以便把活动进程换入或换出内存，进而使处理器的利用率最大化。程序换出到磁盘中后，下次换入时要放到与换出前相同的内存区域会很困难。相反，我们需要把进程重定位到内存的不同区域。

<br/>

7.3　为何不可能在编译时实施内存保护？

由于程序在内存中的位置不可预测，因而在编译时不可能检查绝对地址来确保保护。此外，大多数程序设计语言允许在运行时进行地址的动态计算（如通过计算数组下标或数据结构中的指针）。因此必须在运行时检查进程产生的所有内存访问。

<br/>

7.4　允许两个或多个进程访问内存某一特定区域的原因是什么？

任何保护机制都必须具有一定的灵活性，以允许多个进程访问内存的同一部分。例如，多个进程正在执行同一个程序时，允许每个进程访问该程序的同一个副本，要比让每个进程有自己单独的副本更有优势。合作完成同一个任务的进程可能需要共享访问相同的数据结构。因此，内存管理系统在不损害基本保护的前提下，必允许对内存共享区域进行受控访问。我们将会看到用于支持重定位的机制也支持共享。

<br/>

7.5　在固定分区方案中，使用大小不等的分区有何好处？

可缓解因程序太大而无法放到固定大小的分区和因程序太小产生大量内部碎片的问题。

<br/>

7.6　内部碎片和外部碎片有何区别？

固定分区中，由于装入的数据块小于分区大小，因而导致分区内不存在空间浪费，这种现象称为内部碎片。

动态分区中，随着时间的推移，内存中形成越来越多的碎片，内存的利用率随之下降，这种现象称为外部碎片，指在所有分区外的存储空间变成了越来越多的碎片。

<br/>

7.7　逻辑地址、相对地址和物理地址有何区别？

逻辑地址是指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。

相对地址是逻辑地址的一个特例，它是相对于某些已知点(通常是程序的开始处)的存储单元。

物理地址或绝对地址是数据在内存中的实际位置。

<br/>

7.8　页和页框有何区别？ 

内存被划分成大小固定、相等的块，且块相对比较小，每个进程也被划分成同样大小的块，则进程中称为页的块可以分配到内存中称为页框的可用块。

<br/>

7.9　页和段有何区别？

页大小相等，段可以大小不等；分页对程序员来说是透明的，而分段通常是可见的。

<br/>

8.1　简单分页与虚拟内存分页有何区别？

简单分页：进程运行时，它的所有页必须都在内存中， 除非使用了覆盖技术。

虚存分页：进程运行时，并非所有页都须在内存页框中。仅在需要是才读入页。

<br/>

8.2　什么是抖动？

当操作系统读取一块内存时，它必须把另一块换出。处理器的大部分时间都用于交换块而非执行指令。若一块正好在将要用到之前换出，则操作系统就不得不很快地把它取回。这类操作通常会导致一种称为系统抖动的情况：处理器的大部分时间都用于交换块而非执行指令。

<br/>

8.3　为何使用虚拟内存时，局部性原理至关重要？

局部性原理描述了一个进程中程序和数据引用的集簇倾向。因此，假设在很短的时间内仅需要进程的一部分块是合理的。同时，还可以对将来可能会访问的块进行猜测，从而避免系统抖动。局部性原理表明虚拟内存方案是可行的。

<br/>

8.4　哪些元素是页表项中能找到的典型元素？简单定义每个元素。

页号：虚拟地址的页号部分。

进程标志符：使用该页的进程。页号和进程标志符共同标志一个特定进程的虚拟地址空间的一页。

控制位：该域包含一些标记，比如有效、访问和修改，以及保护和锁定信息。

链指针：若某项没有链项，则该域为空(或用一个单独的位来表示)。否则，该域包含链中下一项的索引值（$0 \sim 2^m - 1$ 之间的数字）。

<br/>

8.5　转换检测缓冲区的目的是什么？

​原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项，另一次取需要的数据。因此，简单的虚拟内存方案会导致内存访问时间加倍。为克服这个问题，大多数虚拟内存方案都为页表项使用了一个特殊的高速缓存，通常称为转换检测缓冲区。

<br/>

8.6　简单定义两种可供选择的页面读取策略。

请求分页：只有当访问到某页中的一个单元时才将该页取入内存。

预先分页：读取的页不是缺页中断请求的页。

<br/>

8.7　驻留集管理和页面置换策略有何区别？

驻留集管理：给每个活动进程分配多少页框。计划置换的页集是局限于那些缺页中断的进程，还是局限于所有页框都在内存中的进程。

置换策略：在计划置换的页集中，选择换出哪一页。

<br/>

8.8　FIFO 和时钟页面置换算法有何联系？

FIFO 和时钟页面置换算法都会扫描缓冲区，FIFO 置换驻留在内存中时间最长的页，在时钟策略中会跳过使用位为 1 的页框。

<br/>

8.9　页缓冲实现什么功能？

被置换的页仍然留在内存中。因此，若进程访问该页，则可迅速返回该进程的驻留集，且代价很小。

已修改的页按簇写回，而不是一次只写一页，因此大大减少了 I/O 操作的数量，进而减少了磁盘访问时间。

<br/>

8.10　为什么不能把全面置换策略和固定分配策略组合起来？

为保持驻留集的大小固定，从内存中移出的一页必须由同一个进程的另一页置换。

<br/>

8.11　驻留集和工作集有何区别？

驻留集表示进程在内存中的页集。

工作集表示进程在过去的一段时间中被访问到的页集。

<br/>

8.12　请求式清除和预约式清除有何区别？

请求式清除：只有当一页被选择用于置换时才被写回辅存。

预约式清除：将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存。

<br/>

9.1　简要描述三种类型的处理器调度。

长程调度：决定加入待执行进程池。

中程调度：决定加入部分或全部位于内存中的进程集合。

短程调度：决定处理器执行哪个可运行进程。

<br/>

9.2　在交互式操作系统中，通常最重要的性能或要求是什么？

相应时间。

<br/>

9.3　周转时间和响应时间有何区别？

周转时间：指一个进程从提交到完成之间的时间间隔，包括实际执行时间和等待资源（包括处理器资源）的时间。

响应时间：对一个交互进程来说，这指从提交一个请求到开始接收响应之间的时间间隔。

<br/>

9.4　对于进程调度，较小的优先级值是表示较低的优先级还是表示较高的优先级？

对于 UNIX 和许多其他操作系统中，优先级数值越大，表示的进程优先级越低。某些系统如 Windows 的用法正好相反，即大数值表示高优先级。

<br/>

9.5　抢占式调度和非抢占式调度有何区别？

非抢占：在这种情况下，一旦进程处于运行状态，就会不断执行直到终止，进程要么因为等待 I/O，要么因为请求某些操作系统服务而阻塞自己。

抢占：当前正运行进程可能被操作系统中断，并转换为就绪态。一个新进程到达时，或中断发生后把一个阻塞态进程置为就绪态时，或出现周期性的时间中断时，需要进行抢占决策。

<br/>

9.6　简单定义 FCFS 调度。

每个进程就绪后，会加入就绪队列。当前正运行的进程停止执行时，选择就绪队列中存在时间最长的进程运行。

<br/>

9.7　简单定义轮转调度。

这种算法周期性地产生时钟中断，出现中断时，当前正运行的进程会放置到就绪队列中，然后基于 FCFS 策略选择下一个就绪作业运行。

<br/>

9.8　简单定义最短进程优先调度。

这是一个非抢占策略，其原则是下次选择预计处理时间最短的进程。

<br/>

9.9　简单定义最短剩余时间调度。

最短剩余时间是在 SPN 中增加了抢占机制的策略。在这种情况下，调度程序总是选择预期剩余时间最短的进程。

<br/>

9.10　简单定义最高响应比优先调度。

当前进程完成或被阻塞时，选择 R 值最大的就绪进程。

<br/>

9.11　简单定义反馈调度。

调度基于抢占原则（按时间片）并使用动态优先级机制。

<br/>

10.1　列出并简单定义 5 种不同级别的同步粒度。

细粒度：单指令流中固有的并行。

中等粒度：一个单独应用中的并行处理或多任务处理。

粗粒度：多道程序环境中并发进程的多处理。

极粗粒度：在网络结点上进行分布式处理，形成一个计算环境。

无约束：多个无关进程。

<br/>

10.2　列出并简单定义线程调度的 4 种技术。

负载分配：进程不分配到某个特定的处理器。系统维护一个就绪线程的全局队列，每个处理器只要空闲就从队列中选择一个线程。

组调度：一组相关的线程基于一对一的原则，同时调度到一组处理器上运行。

专用处理器分配：这种方法与负载分配方法正好相反，它通过把线程指定到处理器来定义隐式的调度。每个程序在其执行过程中，都分配给一组处理器，处理器的数量与程序中线程的数量相等。程序终止时，处理器返回总处理器池，以便分配给另一个程序。

动态调度： 在执行期间，进程中线程的数量可以改变。

<br/>

10.3　列出并简单定义三种版本的负载分配。

先来先服务：一个作业到达时，其所有线程都被连续地放在共享队列末尾。一个处理器变得空闲时，会选择下一个就绪线程执行，直到完成或被阻塞。

最少线程数优先： 共享就绪队列被组织成一个优先级队列，一个作业包含的未调度线程的数量最少时，给它指定最高的优先级。具有相同优先级的队列按作业到达的顺序排队。和 FCFS 一样，被调度的线程一直运行到完成或被阻塞。

可抢占的最少线程数优先： 最高优先级给予具有最少未被调度线程数的作业。若刚到达的作业所包含的线程数少于正在执行作业的线程数，则它将抢占属于这个被调度作业的线程。

<br/>

10.4　硬实时任务和软实时任务有何区别？

硬实时任务是指必须满足最后期限的任务，否则会给系统带来不可接受的破坏或致命的错误。

软实时任务也有一个与之关联的最后期限，且希望能满足这一期限的要求，但并不强制，即使超过了最后期限，调度和完成这个任务仍然是有意义的。

<br/>

10.5　周期性实时任务和非周期性实时任务有何区别？

非周期任务有一个必须结束或开始的最后期限，或者有一个关于开始时间和结束时间的约束。而对于周期任务，这个要求描述成“每隔周期 T 一次”或“每隔 T 个单位”。

<br/>

10.6　列出并简单定义实时操作系统的 5 方面要求。

可确定性：在某种程度上是指它可以按照固定的、预先确定的时间或时间间隔执行操作。

可响应性：在知道中断之后，操作系统为中断提供服务的时间。

用户控制：允许用户细粒度地控制任务优先级。

可靠性：避免性能的损失或降低。

故障弱化操作：系统在故障时尽可能多地保存其性能和数据的能力。

<br/>

10.7　列出并简单定义 4 类实时调度算法。

静态表调度法：执行关于可行调度的静态分析。分析的结果是一个调度，它确定在运行时一个任务何时须开始执行。

静态优先级抢占调度法：执行一个静态分析，但未制定调度，而是通过给任务指定优先级，使得可以使用传统的基于优先级地抢占式调度程序。

基于动态规划的调度法：在运行时动态的确定可行性，而不是在开始运行前离线地确定（静态）。到达的任务仅能在满足其他时间约束时，才可接受并执行。可行性分析的结果是一个调度或规划，可用于确定何时分派这个任务。

动态尽力调度法：不执行可行性分析。系统试图满足所有的最后期限，并终止任何已经开始运行但错过最后期限的进程。

<br/>

10.8　一个任务哪些信息在实时调度时非常有用？

就绪时间：任务开始准备执行的时间。对于重复或周期性的任务，这实际上是一个事先知道的时间序列。而对于非周期性的任务，要么也事先知道这个时间，要么操作系统仅知道什么时候任务真正就绪。

启动最后期限：任务必须开始的时间。

完成最后期限：任务必须完成的时间。典型的实时应用程序要么有启动最后期限，要么有完成最后期限，但不会两者都存在。

处理时间：从执行任务直到完成任务所需的时间。在某些情况下，可以提供这个时间，而在另外一些情况下，操作系统度量指数平均值。其他调度系统未使用这个信息。

资源需求：任务在执行过程中所需的资源集合（处理器以外的资源）。

优先级：度量任务的相对重要性。硬实时任务可能具有绝对的优先级，因为如果错过最后期限则会导致系统失败。系统必须继续运行是，可为硬实时任务和软实时任务指定相关的优先级，进而指导调度程序。

子任务结构：一个任务可以分解为一个必须执行的子任务和一个可选执行的子任务。只有必须执行的子任务拥有硬最后期限。

<br/>

11.1　列出并简单定义执行 I/O 的三种技术。

程序控制 I/O：处理器代表一个进程给 I/O 模块发送一个 I/O 命令；该进程进入忙等待，直到操作完成才能继续执行。

中断驱动 I/O：处理器代表进程向 I/O 模块发出一个 I/O 命令。有两种可能性：若来自进程的 I/O 指令是非阻塞的，则处理器继续执行发出 I/O 命令的进程的后续指令。若 I/O 指令是阻塞的，则处理器执行的下一条指令来自操作系统，它将当前的进程设置为阻塞态并调度其他进程。

直接存储器访问：一个 DMA 模块控制内存和 I/O 模块之间的数据交换。为传送一块数据，处理器给 DMA 模块发请求，且只有在整个数据块传送结束后，它才被中断。

<br/>

11.2　逻辑 I/O 和设备 I/O 有何区别？

逻辑 I/O：逻辑 I/O 模块把设备当作一个逻辑资源来处理，它并不关心实际控制设备的细节。逻辑 I/O 模块代表用户进程管理的普通 I/O 功能，允许用户进程根据设备标识符及诸如打开、关闭、读、写之类的简单指令与设备打交道。

设备 I/O：请求的操作和数据（缓冲的数据、记录等）被转换为适当的 I/O 指令序列、通道命令和控制器指令。可以使用缓冲技术来提高利用率。

<br/>

11.3　面向块的设备和面向流的设备有何区别？各举一些例子。

面向块的设备将信息保存在块中，块的大小通常是固定的，传送过程中一次传送一块。通常可以通过块号访问数据。磁盘和 USB 智能卡都是面向块的设备。

面向流的设备以字节流的方式输入/输出数据，它没有块结构。终端、打印机、通信端口、鼠标和其他指示设备以及其他大多数非辅存设备，都属于面向流的设备。

<br/>

11.4　为什么希望双缓冲而非单缓冲来提高 I/O 性能？

对于面向块的传送，我们可以粗略地估计执行时间为 $max[C, \ T]$。因此，若 $C \leq T$，则有可能使面向块的设备全速运行；另一方面，若 $C > T$，则双缓冲能确保该进程不需要等待 I/O。

<br/>

11.5　在磁盘读或写时有哪些延迟因素？

寻道时间：磁头定位到磁道所需要的时间。

旋转延迟：磁头到达扇区开始位置的时间。

存取时间：到达读或写位置所需要的时间

传输时间：传输所需的时间。

<br/>

11.6　简单定义图 11.7 中描述的磁盘调度策略。

FIFO：先进先出，按顺序处理队列中的项目。

SSTF：最短服务时间优先，选择使磁头臂从当前位置开始移动最少的磁盘 I/O 请求。

SCAN：电梯算法，要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。

C-SCAN：循环 SCAN 策略，把扫描限定在一个方向上。因此，当访问到沿某个方向的最后一个磁道时，磁头臂返回到磁盘相反方向末端的磁道，并再次开始扫描。

<br/>

11.7　简单定义 7 个 RAID 级别

<table>
    <tr>
        <th style="text-align:center;">类别</th>
        <th style="text-align:center;">级别</th>
        <th style="text-align:center;">说明</th>
        <th style="text-align:center;">磁盘请求</th>
        <th style="text-align:center;">数据可用性</th>
        <th style="text-align:center;">大 I/O 数据量传送能力</th>
        <th style="text-align:center;">小 I/O 请求率</th>
    </tr>
    <tr>
        <td>条带化</td>
        <td>0</td>
        <td>非冗余</td>
        <td>N</td>
        <td>低于单个磁盘</td>
        <td>很高</td>
        <td>读和写都很高</td>
    </tr>
    <tr>
        <td>镜像</td>
        <td>1</td>
        <td>被镜像</td>
        <td>2N</td>
        <td>高于 RAID 2、3、4 或 5；低于 RAID 6</td>
        <td>读时高于单个磁盘；写时与单个磁盘相近</td>
        <td>读时最快为单个磁盘的两倍；写时与单个磁盘相近</td>
    </tr>
    <tr>
        <td rowspan="2">并行访问</td>
        <td>2</td>
        <td>通过汉明码实现冗余</td>
        <td>N + m</td>
        <td>明显高于单个磁盘；于 RAID 3、4 或 5 可比</td>
        <td>所有列出方案中最高的</td>
        <td>约为单个磁盘的两倍近</td>
    </tr>
    <tr>
        <td>3</td>
        <td>交错位奇偶校验</td>
        <td>N + 1</td>
        <td>明显高于单个磁盘；于 RAID 2、4 或 5 可比</td>
        <td>所有列出方案中最高的</td>
        <td>约为单个磁盘的两倍</td>
    </tr>
    <tr>
        <td rowspan="3">独立访问</td>
        <td>4</td>
        <td>交错块奇偶校验</td>
        <td>N + 1</td>
        <td>明显高于单个磁盘；于 RAID 2、3 或 5 可比</td>
        <td>读时与 RAID 0 相近；写时明显慢于单个磁盘</td>
        <td>读时与 RAID 0 相似；写时明显慢于单个磁盘</td>
    </tr>
    <tr>
        <td>5</td>
        <td>交错块分布奇偶校验</td>
        <td>N + 1</td>
        <td>明显高于单个磁盘；于 RAID 2、3 或 4 可比较</td>
        <td>读时与 RAID 0 相近；写时慢于单个磁盘</td>
        <td>读时与 RAID 0 相似；写时通常慢于单个磁盘</td>
    </tr>
    <tr>
        <td>6</td>
        <td>交错块双重分布奇偶校验</td>
        <td>N + 2</td>
        <td>所有列出方案中最高的</td>
        <td>读时与 RAID 0 相近；写时慢于 RAID 5</td>
        <td>读时与 RAID 0 相近；写时明显慢于 RAID 5</td>
    </tr>
</table>

<br/>

11.8　典型的磁盘扇区大小是多少？

512Byte。

<br/>

12.1　域和记录有何不同？

域是基本的数据单元。一个域包含一个值，如雇员的名字、日期或传感器读取的值。域可通过其长度和数据类型（如 ASCII 字符串、二进制数等）来描述。域的长度可以是定长的或变长的，具体取决于文件的设计。对于后一种情况，域通常包含两个或三个子域：要保存的实际值、域名，以及某些情况下的域长度。在其他情况下，域之间特殊的分隔符暗示了域的长度。

记录是一组相关域的集合，可视为应用程序的一个单元。例如，一条雇员记录可能包含以下域：名字、社会保险号、工作类型、雇用日期等。同样，记录的长度也可以是定长的或变长的，具体取决于设计。如果一条记录中的某些域是变长的，或记录中域的数量可变，则该记录是变长。对于后一种情况，每个域通常都有一个域名。对于这两种情况，整条记录通常都包含一个长度域。

<br/>

12.2　文件和数据库有何不同？

文件是一组相似记录的集合，它被用户和应用程序视为一个实体，并可通过名字访问。文件有唯一的一个文件名，可被创建或删除。访问控制通常在文件级实施，也就是说，在共享系统中，用户和程序被允许或被拒绝访问整个文件。在有些更复杂的系统中，这类控制也可在记录级或域集实施。

数据库是一组相关的数据的集合，其本质特征是数据元素间存在着明确的关系，且可供不同的应用程序使用。数据库可能包含与一个组织或项目相关的所有信息，如一家商店或一项科学研究。数据库自身由一种或多种类型的文件组成。通常，数据库管理系统是独立于操作系统的，尽管它可能会使用某些文件管理程序。

<br/>

12.3　什么是文件管理系统？

文件管理系统是一组系统软件，它为使用文件的用户和应用程序提供服务。典型情况下，文件管理系统是用户或应用程序访问文件的唯一方式，它可使得用户或程序员不需要为每个应用程序开发专用软件，并为系统提供控制最重要资源的方法。

<br/>

12.4　选择文件组织时的重要原则是什么？

访问快速、易于修改、节约存储空间、维护简单、可靠性。

<br/>

12.5　列出并简单定义 5 种文件组织。

堆：是最简单的文件组织形式。数据按它们到达的顺序被收集，每条记录由一串数据组成。

顺序文件：是最常用的文件组织形式。在这类文件中，每条记录都使用一种固定的格式。所有记录有具有相同的长度，并由相同数量、长度固定的域按特定的顺序组成。

索引顺序文件：保留了顺序文件的关键特征：记录按照关键域的顺序组织。但它增加了两个特征：用于支持随机访问的文件索引和溢出文件。溢出文件类似于顺序文件中使用的日志文件，但溢出文件中的记录可根据它前面记录的指针进行定位。

索引文件：只能通过索引来访问记录。因此，对记录的放置位置不再有限制，只要至少有一个索引的指针指向这条记录即可。此外，还可以使用长度可变的记录。

直接文件或散列文件：开发直接访问磁盘中任何一个地址已知的块的能力。

<br/>

12.6　为何在索引顺序文件中查找一条记录的平均时间小于在顺序文件中的平均时间？

要查找某个特定的域，首先要查找索引，查找关键域值等于目标关键域值或者位于目标观教育值之前且最大的索引，然后在该索引的指针所指的主文件中的位置处开始查找。

为说明该方法的有效性，考虑一个包含 100 万条记录的顺序文件。要查找某个特定的关键域值，平均需要访问 50 万次记录。现在假设创建一个包含了 1000 项的索引，索引中的关键域均匀分布在主文件中。为找到这条记录，平均只需在索引文件中进行 500 次访问，接着在主文件中进行 500 次访问。查找的开销从 500000 降低到了 1000。

<br/>

12.7　对目录执行的典型操作有哪些？

查找：用户或应用程序引用一个文件时，必须查找目录，以找到该文件相应的目录项。

创建文件：创建一个新文件时，必须在目录中增加一个目录项。

删除文件：删除一个文件时，必须在目录中删除相应的目录项。

显示目录：可能会请求目录的全部或部分内容。通常，这个请求是由用户发出的，用于显示该用户所拥有的所有文件和每个文件的某些属性（如类型、访问控制信息、使用信息）。

修改目录：由于某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。

<br/>

12.8　路径名和工作目录有何关系？

一系列目录名和最后到达的文件名组成了该文件的路径名。

对交互用户或进程而言，总有一个当前路径与之相关联，通常称为工作目录。

<br/>

12.9　可以授予或拒接的某个特定用户对某个特定文件的访问权限有哪些？

无：用户甚至不知道文件是否存在，更不必说访问它。为实施这种限制，不允许用户读包含该文件的用户目录。

知道：用户可确定文件是否存在并确定其所有者。用户可向所有者请求更多的访问权限。

执行：用户可加载并执行一个程序，但不能复制它。私有程序通常具有这种访问限制。

读：用户能以任何目的读文件，包括复制和执行。有些系统还可区分浏览和复制，对于前一种情况，文件内容可以呈现给用户，但用户却无法进行复制。

追加：用户可给文件添加数据，通常只能在末尾追加，但不能修改或闪出文件的任何内容。在许多资源中收集数据时，这种权限非常有用。

更新：用户可修改、删除和增加文件中的数据。通常包括最初写文件、完全重写或部分重写、移去所有或部分数据。有些系统还区分不同程度的更新。

改变保护：用户可以改变已授给其他用户的权限。通常，只有文件的所有者该具有这一权力。在某些系统中，所有者可把这项权力扩展到其他用户。为防止滥用这种机制，文件的所有者通常能指定该项权力的持有者改变哪些权限。

删除：用户可以从文件系统中删除该文件。

<br/>

12.10　列出并简单定义三种组块方法。

定长组块：使用定长的记录，且若干完整的记录保存在一个块中。在每个块的末尾可能会有一些未使用的空间，称为内部碎片。

变长跨越式组块：使用变长的记录，并紧缩到块中，使得块中不存在未使用的空间。因此，某些记录可能会跨越两个块，两个块通过一个指向后续块的指针连接。

变长非跨越式组块：使用变长的记录，但并不采用跨越方式。若下一条记录比块中剩余的未使用空间大，则无法使用这一部分，因此在大多数块中都会有未使用的空间。

<br/>

12.11　列出并简单定义三种文件分配方法。

连续分配：是指在创建文件时，给文件分配一组连续的块。

链式分配：基于单个块，链中的每块都包含指向下一块的指针。

索引分配：每个文件在文件分配表中都有一个索引。分配给该文件的每个分区在索引中都有一个表项。

<br/>

13.1　什么是嵌入式系统？

嵌入式系统是指在电子设备中使用的具有特定功能或功能集的电子设备和软件，而不是通用计算机，如笔记本或台式计算机。

<br/>

13.2　嵌入式系统的典型需求或限制有哪些？

实时操作：在许多嵌入式系统中，计算的准确性部分取决于它的交付时间。通常，实时性约束由外部 I/O 和控制稳定性决定。

响应操作： 嵌入式软件可以响应外部事件并执行。若这些事件不是周期性发生的，或者不是以可预测的间隔发生的，则嵌入式软件可能需要考虑最坏的情况并为执行例程设置优先级。

可配置性：由于嵌入式操作系统种类繁多，嵌入式操作系统功能的（定性和定量）要求存在很大差异。因此，旨在用于这种嵌入式系统的嵌入式操作系统必须能够灵活配置，满足特定应用程序和硬件所需的功能。

I/O 设备的灵活性：没有一个设备需要所有版本操作系统的支持，且 I/O 设备涵盖的范围很宽。

简化的保护机制：嵌入式系统通常用于有限的，定义明确的功能。未经测试的程序很少添加到软件中。在软件完成配置和测试后，我们就假设它是可靠的。因此，除各种安全措施外，嵌入式系统的保护机制有限。比如，I/O 指令不一定是可以陷入操作系统的高级指令，任务可以直接运行各自的 I/O。类似地，存储器保护机制可能被尽量简化了。

直接使用中断：通用操作系统通常不允许用户进程直接使用中断。

<br/>

13.3　什么是嵌入式操作系统？

嵌入式操作系统是指用于嵌入式系统的操作系统。

<br/>

13.4　嵌入式操作系统的关键特点有哪些？

拥有快速轻量级的进程和线程切换机制。

调度算法是实时的，调度模块是调度系统的一部分而一个组件。

占用空间更小。

快速响应外部中断；通常要求是响应时间小于 10μs。

最小化中断的时间间隔。

为内存管理提供固定或可变大小的分区，以及锁定内存中的代码和数据的能力。

提供可以快速累积数据的特殊顺序文件。

<br/>

13.5　与为特定目的而构建的嵌入式操作系统相比，基于现有商业操作系统的嵌入式操作系统有何优缺点？

优点是从商业通用 OS 衍生出来的嵌入式 OS 有一组为人熟知的接口，这增强了系统的可移植性。缺点是与专用嵌入式操作系统相比，此类操作系统通常较慢且可预测性较差。

<br/>

13.6　什么是 TinyOS 的目标应用程序？

无线传感器网络。

<br/>

13.7　TinyOS 的设计目标有哪些？

允许高并发性：在典型的无线传感器网络应用中，设备要求有强并发性。几个不同的数据流必须同步移动。当传感器数据在一个稳定的流中输入时，处理结果也须在稳定的流中进行传送。另外，必须管理对遥控传感器和基站的外部控制。

在有限的资源下操作：TinyOS 的目标平台会受到存储器和计算资源的限制，并靠电池或太阳能运行。单个平台可能仅提供几 KB 的程序存储器和几百字节的随机存储器。软件必须高效地使用可用的处理器和存储器资源，并允许低功耗通信。

适应硬件升级：大部分硬件都是在不断升级的；应用软件和大部分系统服务必须兼容硬件换代。也就是说，若功能相同，则在升级硬件是应没有或只有很少的软件改变。

支持广泛的应用软件：应用软件在其生命周期、通信和传感等方面展示了宽广的需求范围。因此需要模块化、通用的嵌入式操作系统，以便在开发和支持软件时能有标准化的方法来节约成本。

支持不同的平台：如前所述，需要通用的嵌入式操作系统。

应是鲁棒的：传感器网络一旦部署，就须在无人监控的状态下运行数月或数年。理想情况下，单个系统和传感器网络都应是冗余的。实际上，两种类型的冗余都需要额外的资源。可增强健壮性的软件的特点是，使用高度模块化、标准化的软件组件。

<br/>

13.8　什么是 TinyOS 的组件？

使用 TinyOS 构建的嵌入式系统由一组称为组件的小模块组成。每个组件完成一个简单的任务或一组任务，每个组件与其他组件和硬件的接口受到一定限制且定义明确。

<br/>

13.9　TinyOS 操作系统的软件组成是怎样的？

体系结构由分层排列的组件组成。每个组件仅能连接其他两个组件，一个比它层次低，一个比它层次高。组件向低层组件发出命令并从低层组件接收事件信号。类似地，组件接收来自高层组件的命令，并向高层组件发送事件信号。底层的组件是硬件组件，最顶层的组件是应用软件组件，这种组件可能不是 TinyOS 标准套件中的一部分，但必须符合 TinyOS 组件的结构。

<br/>

13.10　TinyOS 的默认调度策略是怎样的？

TinyOS 中默认的调度程序是一个简单的 FIFO 队列。

<br/>

14.1　简要描述类型 1 和类型 2 虚拟化。

类型 1 虚拟管理程序作为软件层直接加载到物理层服务器上，就像加载操作系统一样。类型 1 管理程序可以直接控制主机的物理资源。安装和配置后，服务器就可以支持虚拟机作为客户虚拟机。在成熟环境中，虚拟化主机聚集在一起以提高可用性和负载平衡，可以在新主机上暂存管理程序。然后，新主机将加入现有集群，并且可以将 VM 移至新主机。而不会中断任何服务。

类型 2 虚拟管理程序利用主机操作系统的资源和功能，并在操作系统上作为软件模块运行。它依赖于操作系统来代表虚拟机管理程序处理所有硬件交互。

<br/>

14.2　简要描述容器虚拟化。

使用容器虚拟化方法时，需要让称为虚拟化容器的软件在主机操作系统内核之上运行，这种软件为应用程序提供隔离的执行环境。与基于虚拟管理程序的 VM 不同，容器不会模拟物理模拟器。与之相反，主机上所有容器化应用程序共享一个共同的操作系统内核。这消除了为每个应用程序运行单独的操作系统所需的资源，大大减少了开销。

<br/>

14.3　解释膨胀的概念。

内存资源发生竞争时，虚拟机管理程序通过膨胀“气球”，把虚拟机操作系统的页面“挤压”到硬盘。页被清除后，“气球”便会“释放”，虚拟机管理程序就可把内存提供给其他虚拟机使用。

<br/>

14.4　简要描述 Java 虚拟机。

JVM 可描述为一个抽象的计算设备，它包含指令集、一个 PC（程序计数器）寄存器、一个用来保存变量和结果的栈、一个保存运行时数据和垃圾收集的堆、一个存储代码的常量的方法区。

<br/>

15.1　对于特定的文件和特定的用户，允许/拒绝的典型访问权限是怎样的？

一个代表用户执行的进程拥有系统授予该用户的权限。系统或公用进程可能在配置时分配权限。

<br/>

15.2　列出并简要给出三种入侵者的定义。

伪装者：未被授权使用计算机的个体，它越过了系统访问控制并使用了一个合法的用户账户。

违法者：合法用户，但访问了未被授权的数据、程序或资源，或被授权访问但错误使用了权限。

秘密用户：能控制系统的个体，它通过使用这种控制来逃避审查与访问控制，或停止审计数据的收集。

<br/>

15.3　总体来讲，认证用户身份有哪 4 种方法？

个体知道的信息：如密码、个人识别号或预定义问题集的答案。

个体拥有的信息：如电子卡、智能卡、物理钥匙。用来认证的这类认证者称为令牌。

个体是什么（静态生物测定）：如通过指纹、视网膜和脸部进行的识别。

个体做什么（动态生物测定）：如声音模式、笔迹特征、打字节奏等。

<br/>

15.4　简要描述 DAC 和 RBAC 的区别。

传统的 DAC 系统为单个用户或用户群组定义访问权限。相比之下，RBAC 则基于用户在系统中的角色而非用户标识来定义访问权限。

<br/>

15.5　哪种类型的编程语言易收到缓冲区溢出攻击？

编译器不包含自动触发边界检测的代码的编程语言。

<br/>

15.6　防御缓冲区溢出工具的两类方法是什么？

编译时防御，目标是通过程序来抵御对新程序的攻击。

运行时防御，目标是探测并阻止对已有程序的攻击。

<br/>

15.7　列举并简要描述在编译新软件时能用的一些抵御缓冲区溢出的方法。

编程语言的选择：使用一种现代高级编程语言编写程序，这种语言拥有严格的变量类型概念，且对允许哪些操作有严格的规定。

安全编码技术：程序员需要检查这些代码，用一种安全的方式重写任何不安全的代码结构。

语言扩展及使用安全库：略。

栈保护机制：为函数配备进入和退出代码的标示，并检查栈空间以避免崩溃的出现。若发现任何更改，则终止程序而非放任攻击继续进行。

<br/>

15.8　列举并简要描述运行有缺陷的软件时，能执行的防御缓冲区溢出的方法。

可执行的地址空间保护：阻断代码在栈中的执行，并假设应该只能在进程地址空间的其他位置找到可执行代码。

地址空间布局随机化：为每个进程随机地改变栈所在的地址。

守卫页：可将守卫页放在一段进程地址空间的各个存储器临界区之间。

<br/>

16.1　定义云计算。

云计算：一种模型，支持对共享的可配置计算资源（如网络、服务器、存储、应用程序和服务）进行无所不在的、方便的、随需应变的网络工作访问，这些资源可通过最少的管理与服务提供者的交互快速进行调配和发布。该云模型可提高可用性，并且有五个基本特征、三个服务模型和四个部署模型组成。

<br/>

16.2　列出并简要定义三种云服务模型。

软件即服务：SaaS 以软件的形式为客户提供服务，特别是应用软件，这些软件在云上运行并可在云中访问。

平台即服务：PaaS 以平台的形式向客户提供服务，客户的应用程序可以在该平台上运行。

基础设施即服务：用户借助 IaaS 能够使用底层云基础设施。

<br/>

16.3　什么是云计算参考架构？

云计算参考架构关注的是云服务提供了“什么”，而不是“如何”设计解决方案和实施。参考架构旨在增进对云计算操作复杂性的理解。它不代表特定云计算系统的系统架构；相反，它是使用通用参考架构描述、讨论和开发特定与系统的体系架构的工具。

<br/>

16.4　列出并简要定义云操作系统的关键组件。

虚拟化：虚拟机技术可将专用应用程序、网络和存储服务迁移到现成的商用服务器上。

虚拟计算：云操作系统的虚拟计算组件控制 IaaS 云计算环境中的虚拟机。

虚拟存储：云操作系统的虚拟存储组件为云基础架构提供数据存储服务。

虚拟网络：云操作系统的虚拟网络组件为云基础架构提供网络服务。

数据结构管理：云操作系统不仅提供原始存储功能，而且提供以结构化方式访问数据的服务。

管理和控制：云操作系统管理好控制组件的主要作用是控制 IaaS 环境。

<br/>

16.5　云操作系统与 IaaS 之间是什么关系？

云操作系统是实现了 IaaS 的软件

<br/>

16.6　什么是 OpenStack？

OpenStack 是 OpenStack Foundation 的一个开源软件项目，旨在产生一个开源云操作系统，主要目的是在云计算中创建和管理庞大的虚拟专用服务器组。

<br/>

16.7　定义物联网。

物联网是一个用于描述智能设备扩展互联的术语，这里的“智能设备”大到电器，小到微型传感器。物联网的一个主题是将短距离移动手法设备嵌入各种小工具和日常用品，从而实现人与物、物与物之间的新型通信形式。

<br/>

16.8　列出并简要定义一个物联网的主要组成部分。

传感器：传感器测量物理、化学或生物实体的某些参数，并以模拟电压电平或数字信号的形式传递相应的电子信号。在这两种情况下，传感器的输出通常会输入微控制器或其他管理元件。

执行器：执行器从控制器接受电信号，并通过与环境的相互作用做出响应，从而对物理、化学或生物实体的某些参数产生影响。

微控制器：深度嵌入式微控制器提供了智能设备中的“智能”。

收发器：收发器包含发送和接收数据所需的电子设备。

射频识别：使用无线电波识别物品的 RFID 技术正日益成为物联网的一项有效技术。

<br/>

16.9　物联网操作系统应满足哪些要求？

内存占用小：与智能手机和各种更大嵌入式设备相比，这种内存的规模要小很多个数量级。

对异构硬件的支持：受限设备上采用的通信技术也多种多样。

网络连接：网络连接对于数据收集、分布式物联网应用开发和远程系统维护至关重要。

能效：对于任何嵌入式设备，尤其是受限设备，能效都是至关重要的。

实时功能：许多物联网设备需要支持实施操作。

<br/>

16.10　什么是 RIOT？

RIOT 是一种专为受限的物联网设备设计的开源操作系统。