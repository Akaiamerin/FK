## 参考教材：[数据结构习题解析与实验指导](https://book.douban.com/subject/30275733)
### 第 2 章　线性表
[（1）](./chapter2/2.1.cpp)将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其它的存储空间。表中不允许有重复的数据。

<br/>

[（2）](./chapter2/2.2.cpp)将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其它的存储空间。表中允许有重复的数据。

<br/>

[（3）](./chapter2/2.3.cpp)已知两个链表 ~~A~~ `list1` 和 ~~B~~ `list2` 分别表示两个集合，其元素递增排列。请设计算法求出 ~~A~~ `list1` 与 ~~B~~ `list2` 的交集，并存放于 ~~A~~ `list1` 链表中。

<br/>

[（4）](./chapter2/2.4.cpp)已知两个链表 ~~A~~ `list1` 和 ~~B~~ `list2` 分别表示两个集合，其元素递增排列。请设计算法求出两个集合 ~~A~~ `list1` 和 ~~B~~ `list2` 的差集（即仅由在 ~~A~~ `list1` 中出现而不在 ~~B~~ `list2` 中出现的元素所构成的集合），并以同样的形式存储，同时返回该集合的元素个数。

<br/>

[（5）](./chapter2/2.5.cpp)设计算法将一个带头结点的单链表 ~~A~~ `list` 分解为两个具有相同结构的链表 ~~B~~ `list1` 和 ~~C~~ `list2`，其中 ~~B~~ `list1` 表的结点为 ~~A~~ `list` 表中值小于零的结点，而 ~~C~~ `list2` 表的结点为 ~~A~~ `list` 表中值大于零的结点（链表 ~~A~~ `list` 中的元素为非零整数，要求 ~~B~~ `list1`、 ~~C~~ `list2` 表利用 ~~A~~ `list` 表的结点）。

<br/>

[（6）](./chapter2/2.6.cpp)设计一个算法，通过一趟遍历确定长度为 n 的单链表中值最大的结点。

<br/>

[（7）](./chapter2/2.7.cpp)设计一个算法，将链表中所有结点的链接方向“原地”逆转，即要求利用原表的存储空间，换句话说，要求算法的空间复杂度为 $O(1)$ 。

<br/>

[（8）](./chapter2/2.8.cpp)设计一个算法，删除递增有序链表中值大于 `mink` 且小于 `maxk` 的所有元素（ `mink` 和 `maxk` 是给定的两个参数，其值可以和表中的元素相同，也可以不同）。

<br/>

[（9）](./chapter2/2.9.cpp)已知 ~~p~~ `cur_node` 指向双向循环链表中的一个结点，其结点结构为 ~~data~~  `elem`、 ~~prior~~ `prev`、 `next` 三个域，写出算法 ~~change(p)~~ `Exchange`，交换 ~~p~~ `cur_node` 所指向的结点及其前驱结点的顺序。

<br/>

[（10）](./chapter2/2.10.cpp)已知长度为 n 的线性表 ~~A~~ `list` 采用顺序存储结构，请写一时间复杂度为 $O(n)$ 、空间复杂度为 $O(1)$ 的算法，该算法删除线性表中所有值为 ~~item~~ `del_elem` 的数据元素。

<br/>

### 第 3 章　栈和队列
[（1）](./chapter3/3.1.cpp)将编号为 `0` 和 `1` 的两个栈存放于一个数组空间 ~~V[m]~~ `elem[cap]` 中，栈底分别处于数组的两端。当第 `0` 号栈的栈顶指针 `top[0]` 等于 `-1` 时该栈为空；当第 `1` 号栈的栈顶指针 `top[1]` 等于 ~~m~~ `cap` 时，该栈为空。两个栈均从两端向中间增长。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算
法的函数。双栈数据结构的定义如下：

<br/>

[（2）](./chapter3/3.2.cpp)回文是指正读反读均相同的字符序列，如“aba”和“abda”均是回文，但“good”不是回文。试写一个算法判定给定的字符向量是否为回文。（提示：将一半字符入栈）

<br/>

[（3）](./chapter3/3.3.cpp)设从键盘输入一整数的序列：$a_{1}, \ a_{2}, \ a_{3}, \ \dots, \ a_{n}$，试编写算法实现：用栈结构存储输入的整数，当 $a_{i} \neq -1$ 时，将 $a_{i}$ 进栈；当 $a_{i} = -1$ 时，输出栈顶整数并出栈。算法应对异常情况（入栈满等）给出相应的信息。

<br/>

[（4）](./chapter3/3.4.cpp)从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以“`$`”符作为输入结束，操作数之间用空格分隔，操作符只可能有 `+` 、 `-` 、 `*` 、 `/` 种运算。例如： `234 34+2*$` 。

<br/>

[（5）](./chapter3/3.5.cpp)假设以 `I` 和 `O` 分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由 `I` 和 `O` 组成的序列，称可以操作的序列为合法序列，否则称为非法序列。

~~① 下面所示的序列中哪些是合法的？~~

$A. \ IOIOO \qquad B. \ IOIOIO \qquad C. \ IOIO \qquad D. \ IOIO$

② 通过对 ① 的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回 `true`，否则返回 `false` （假定被判定的操作序列已存入一维数组中）。

<br/>

[（6）](./chapter3/3.6.cpp)假设以带头结点的循环链表示队列，并且只设一个指针指向队尾元素站点(注意不设头指针)，试编写相应的置空队列、判断队列是否为空 、入队和出队等算法。

<br/>

[（7）](./chapter3/3.7.cpp)假设以数组 ~~Q[m]~~ `elem[cap]` 存放循环队列中的元素，同时设置一个标志 `tag`，以 `tag == 0` 和 `tag == 1` 来区别在队头指针(`front`)和队尾指针(`rear`)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(~~enqueue~~ `Enqueue`)和删除(~~dequeue~~ `Dequeue`)算法。

<br/>

[（8）](./chapter3/3.8.cpp)如果允许在循环队列的两端都可以进行插入和删除操作。要求：

① 写出循环队列的类型定义；

② 写出“从队尾删除”和“从队头插入”的算法。

<br/>

[（9）](./chapter3/3.9.cpp)已知 `Ackerman` 函数定义如下：

① 写出计算 `Ack(m, n)` 的递归算法，~~并根据此算法给出 Ack(2, 1) 的计算过程~~。

② 写出 `Ack(m, n)` 的非递归算法

<br/>

[（10）](./chapter3/3.10.cpp)~~已知 f 为单链表的表头指针~~，链表中存储的都是整型数据，试写出实现下列运算的递归算法：

① 求链表中的最大整数；

② 求链表的结点个数；

③ 求所有整数的平均值。

<br/>

### 第 4 章　串、数组和广义表
[（1）](./chapter4/4.1.cpp)写一个算法统计在输入字符串中各个不同字符出现的频度~~并将结果存入文件~~（字符串中的合法字符为 `A ~ Z` 这 26 个字母和 `0 ~ 9` 这 10 个数字）。

<br/>

[（2）](./chapter4/4.2.cpp)写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。

<br/>

[（3）](./chapter4/4.3.cpp)编写算法，实现下面函数的功能。函数 ~~void ins(char * s, char * t, int pos)~~ `void Ins(char * str, char * ins_str, int ins_index)` 将字符串 ~~t~~ `ins_str` 插入到字符串 ~~s~~ `str` 中，插入位置为 ~~pos~~ `ins_index`。假设分配给字符串 ~~s~~ `str` 的空间足够让字符串 ~~t~~ `ins_str` 插入。（说明：不得使用任何库函数）

<br/>

[（4）](./chapter4/4.4.cpp)已知字符串 ~~S1~~ `str1` 中存放一段英文，写出算法 ~~format(s1, s2, s3, n)~~ `Format(str1, str2, str3, n)`，将其按给定的长度 `n` 格式化成两端对齐的字符串 ~~S2~~ `str2`（即长度为 `n` 且首尾字符不得为空格字符），其多余的字符送 ~~S3~~ `str3` 。

<br/>

[（5）](./chapter4/4.5.cpp)设二维数组 ~~a[1...m, 1...n]~~ `arr[row][col]` 含有 ~~m * n~~ `row * col` 个整数。

① 写一个算法判断 ~~a~~ `arr` 中所有元素是否互不相同？输出相关信息(`yes/no`)；

~~② 试分析算法的时间复杂度。~~

<br/>

[（6）](./chapter4/4.6.cpp)设任意 n 个整数存放于数组 ~~A[1...n]~~ `arr[n]` 中，试编写算法，将所有正数排在所有负数前面（要求算法复杂度为 $O(n)$ ）。

<br/>

### 第 5 章　树和二叉树
以二叉链表作为二叉树的存储结构，编写以下算法：

[（1）](./chapter5/5.1.cpp)统计二叉树的叶结点个数。

<br/>

[（2）](./chapter5/5.2.cpp)判别两棵树是否相等。

<br/>

[（3）](./chapter5/5.3.cpp)交换二叉树每个结点的左孩子和右孩子。

<br/>

[（4）](./chapter5/5.4.cpp)设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。

<br/>

[（5）](./chapter5/5.5.cpp)计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。

<br/>

[（6）](./chapter5/5.6.cpp)用按层次顺序遍历二叉树的方法，统计树中具有度为 `1` 的结点数目。

<br/>

[（7）](./chapter5/5.7.cpp)求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。

<br/>

[（8）](./chapter5/5.8.cpp)输出二叉树中从每个叶子结点到根结点的路径。

<br/>

### 第 6 章　图
[（1）](./chapter6/6.1.cpp)分别以邻接矩阵和邻接表作为存储结构，实现以下图的基本操作：

① 增加一个新顶点 ~~v~~ `vex`，~~insVex(G, v)~~ `InsVex` ;

② 删除顶点 ~~v~~ `Vex` 及其相关的边，~~DeleteVex(G, v)~~ `DelVex`;

③ 增加一条边 ~~<v，w>~~ `<begin_vex, end_vex>`，~~insArc(G, v, w)~~ `InsEdge`;

④ 删除一条边 ~~<v，w>~~ `<begin_vex, end_vex>`，~~DeleteArc~~ `DelEdge`。

<br/>

[（2）](./chapter6/6.2.cpp)一个连通图采用邻接表作为存储结构，设计一个算法，实现从顶点 ~~v~~ `vex` 出发的深度优先遍历的非递归过程。

<br/>

[（3）](./chapter6/6.3.cpp)设计一个算法，求图 ~~G~~ `graph` 中距离顶点 ~~v~~ `vex` 的最短路径长度最大的一个顶点，设 ~~v~~ `vex` 可达其余各个顶点。

<br/>

[（4）](./chapter6/6.4.cpp)试基于图的深度优先搜索策略写一算法，判别以邻接表方式存储的有向图中是否存在由顶点 ~~vi~~ `begin_vex` 到顶点 ~~vj~~ `end_vex` 的路径（~~i≠j~~）。

<br/>

[（5）](./chapter6/6.5.cpp)采用邻接表存储结构，编写一个算法，判别无向图中任意给定的两个顶点之间是否存在一条长度为 ~~k~~ `length` 的简单路径。

<br/>

### 第 7 章　查找
[（1）](./chapter7/7.1.cpp)试写出折半查找的递归算法。

<br/>

[（2）](./chapter7/7.2.cpp)试写一个判别给定二叉树是否为二叉排序树的算法。

<br/>

[（3）](./chapter7/7.3.cpp)已知二叉排序树采用二叉链表存储结构，根结点的指针为 ~~T~~ `root`，链结点的结构为（~~lchild, data, rchild~~）`(elem, left, right)`，其中 ~~lchild~~ `left`，~~rchild~~ `right` 分别指向该结点左、右孩子的指针，~~data~~ `elem` 域存放结点的数据信息。请写出递归算法，从小到大输出二叉排序树中所有数据值 `≥x` 的结点的数据。要求先找到第一个满足条件的结点后，再依次输出其他满足条件的结点。

<br/>

[（4）](./chapter7/7.4.cpp)已知二叉树 ~~T~~ `tree` 的结点形式为（~~llink, data, count, rlink~~）`(elem, count, left, right)`，在树中查找值为 `X` 的结点，若找到，则记数`（count）加 1 `，否则，作为一个新结点插入树中，插入后仍为二叉排序树，写出其非递归算法。

<br/>

[（5）](./chapter7/7.5.cpp)假设一棵平衡二叉树的每个结点都表明了平衡因子 ~~b~~ `balence_factor`，试设计一个算法，求平衡二叉树的高度。

<br/>

[（6）](./chapter7/7.6.cpp)分别写出在散列表中插入和删除关键字为 ~~K~~ `elem` 的一个记录的算法，设散列函数为 ~~H~~ `HashFun`，解决冲突的方法为链地址法。

<br/>

### 第 8 章　排序
[（1）](./chapter8/8.1.cpp)试以单链表为存储结构，实现简单选择排序算法。

<br/>

[（2）](./chapter8/8.2.cpp)有 n 个记录存储在带头结点的双向链表中，现用双向冒泡排序法对其按上升序进行排序，请写出这种排序的算法。（注：双向冒泡排序即相邻两趟排序向相反方向冒泡）。

<br/>

[（3）](./chapter8/8.3.cpp)设有顺序放置的 n 个桶，每个桶中装有一粒砾石，每粒砾石的颜色是红，白，蓝之一。要求重新安排这些砾石，使得所有红色砾石在前，所有白色砾石居中，所有蓝色砾石居后，重新安排时对每粒砾石的颜色只能看一次，并且只允许交换操作来调整砾石的位置。

<br/>

[（4）](./chapter8/8.4.cpp)编写算法，对 n 个关键字取整数值的记录序列进行整理，以使所有关键字为负值的记录排在关键字为非负值的记录之前，要求：

① 采用顺序存储结构，至多使用一个记录的辅助存储空间；

② 算法的时间复杂度为 $O(n)$ 。

<br/>

[（5）](./chapter8/8.5.cpp)借助于快速排序的算法思想，在一组无序的记录中查找给定关键字值等于 ~~key~~ `elem` 的记录。设此组记录存放于数组 ~~r[l...n]~~ `arr[n]` 中。若查找成功，则输出该记录在 ~~r~~ `arr` 数组中的位置~~及其值，否则显示“not find”信息~~。请简要说明算法思想并编写算法。

<br/>

[（6）](./chapter8/8.6.cpp)有一种简单的排序算法，叫做计数排序。这种排序算法对一个待排序的表进行排序，并将排序结果存放到另一个新的表中。必须注意的是，表中所有待排序的关键字互不相同，计数排序算法针对表中的每个记录，扫描待排序的表一趟，统计表中有多少个记录的关键字比该记录的关键字小。假设针对某一个记录，统计出的计数值为 c，那么，这个记录在新的有序表中的合适的存放位置即为 c。

~~① 给出适用于计数排序的顺序表定义；~~

② 编写实现计数排序的算法；

~~③ 对于有 n 个记录的表，关键字比较次数是多少？~~

~~④ 与简单选择排序相比较，这种方法是否更好？为什么？~~