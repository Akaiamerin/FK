## 参考教材：[数据库系统概论（第5版）](https://book.douban.com/subject/26317662)
### 第 1 章　绪论
1.　试述数据、数据库、数据库管理系统、数据库系统的概念。

数据是数据库中存储的基本对象，是描述事物的符号记录。数据有多种表现形式，它们都可以经过数字化后存入计算机。数据的种类有数字、文字、图形、图像、音频、视频等。

数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述、储存，具有较小的冗余度、较高的数据独立性、易扩展性，并可为各种用户共享。数据库数据具有永久存储、有组织、可共享三个基本特点。

数据库管理系统是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。

数据库系统是由数据库、数据库管理系统（及其开发工具）、应用程序、数据库管理员组成的存储、管理、处理、维护数据的系统。

<br/>

2.　使用数据库系统有什么好处？

使用数据库系统的好处是由数据库管理系统的特点决定的，例如：

可以大大提高应用开发的效率。在数据库系统中，应用程序不必考虑数据库的定义、存储、数据存取的具体路径，这些工作都由 DBMS 来完成。开发人员可以专注于应用逻辑的设计，而不必为数据管理的许多复杂细节操心。

数据库系统提供了数据和程序之间的独立性。当应用逻辑发生改变，数据的逻辑结构需要改变时，DBA 负责修改数据的逻辑结构，开发人员不必修改应用程序，或者只需要修改很少的应用程序，从而既简化了应用程序的编制，又大大减少了应用程序的维护和修改，方便用户的使用。

使用数据库系统可以减轻数据库系统管理人员维护系统的负担。因为 DBMS 在数据库建立、运用、维护时对数据库进行统一的管理和控制，包括数据的完整性、安全性、多用户并发控制、故障恢复等，都由 DBMS 执行。

总之，使用数据库的优点很多，既便于数据的集中管理，控制数据冗余，提高数据的利用率和一致性，又有利于应用程序的开发和维护。

<br/>

3.　试述文件系统与数据库系统的区别和联系。

区别：文件系统面向某一应用程序；共享性差，冗余度大；独立性差；记录内有结构整体无结构；由应用程序自己控制。数据库系统面向现实世界；共享性高，冗余度小；具有高度的物理独立性和一定的逻辑独立性；整体结构化，用于数据模型描述；由数据库管理系统提供数据安全性、完整性、并发控制、恢复能力。

联系：文件系统与数据库系统都是计算机系统中管理数据的软件。文件系统时操作系统的重要组成部分；DBMS 是独立于操作系统的软件。DBMS 是在操作系统的基础上实现的；数据库中数据的组织和存储时通过操作系统中的文件系统来实现的。

<br/>

4.　举出适合文件系统而不是数据库系统的应用例子，以及适合用数据库系统的应用例子。

适合文件系统而不是数据库系统的应用例子：数据的备份，软件或应用程序使用过程中的临时数据存储一般使用文件系统比较合适。功能比较简单、比较固定的应用系统也适合文件系统。

适合用数据库系统的应用例子：目前，几乎所有企业或部门的信息系统都以数据库为基础，都使用数据库。例如：一个工厂的信息管理系统（其中包括许多子系统，如库存管理系统、物资采购系统、作业调度系统、设备管理系统、人事管理系统等）、学校的学生管理系统、人事管理系统、图书馆的图书管理系统等，都适合用数据库系统。

<br/>

5.　试述数据库系统的特点。

数据结构化。数据库实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。

数据的共享性高，冗余度低、易扩充。数据库系统从整体角度看待和描述数据，数据不再面向某个应用程序而是面向整个系统，因此数据可以被多个用户、多个应用共享使用。数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。由于数据面向整个系统，是有结构的数据，不仅可以被多个应用共享使用，而且容易增加新的应用，这就使得数据库弹性大，易于扩充，可以适应各种用户的要求。

数据独立性高。数据独立性包括数据的物理独立性和逻辑独立性。数据的独立性是由数据库管理系统提供的二级映像功能来保证的。

数据由数据库管理系统统一管理和控制。数据库的共享是并发的共享，即多个用户可以同时存取数据库中的数据，甚至可以同时存取数据区中同一个数据，为此，数据库管理系统必须提供统一的数据控制功能，包括数据的安全性保护、数据的完整性检查、并发控制、数据库恢复。

<br/>

6.　数据库管理系统的主要功能有哪些？

数据定义功能。数据库管理系统提供数据定义语言（Data Definition Language，DDL），用户通过它可以方便地对数据库中的数据对象进行定义。

数据组织、存储、管理功能。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方法（如索引查找、Hash 查找、顺序查找等）来提高存取效率。

数据操纵功能。数据库管理系统还提供数据操作语言（Data Manipulation Language，DML），用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除、修改等。

数据库的事务管理和运行管理。数据库在建立、运用和维护时由数据库管理系统统一管理、同一控制，以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。

数据库的建立和维护功能。数据库的建立和维护功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。这些功能通常是由一些使用程序或管理工具完成的。

其他功能。其他功能包括数据库管理系统与网络中其他软件系统的通信功能，一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能，异构数据库之间的互访和互操作功能等。

<br/>

7.　什么是概念模型？试述概念模型的作用。

概念模型也称信息模型，它是按用户的观点来对数据和信息建模。主要用于数据库设计。

概念模型的作用：概念模型实际上是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言。

<br/>

8.　定义并解释概念模型中以下术语：

实体，实体型，实体集，实体之间的联系

实体：客观存在并可以相互区分的事务。

实体型：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体。

实体集：同型实体的集合。

实体之间联系：一对一、一对多、多对多等多种类型。

<br/>

9.　试述数据模型的概念、数据模型的作用和数据模型的三个要素。

数据模型的概念：数据模型是对现实世界数据特征的抽象，一般地讲，数据模型是严格定义的概念的集合。

数据模型的作用：数据模型用来描述数据、组织数据、对数据进行操作。这些概念精确地描述了系统的静态特性、动态特定、完整性约束条件。

<dl>
    数据模型的三个要素：
    <dd>数据结构：描述数据库的组成对象以及对象之间的联系。是所描述对象类型的集合，是对系统静态特性的描述。</dd>
    <dd>数据操作：是指对数据库中各个对象（型）的实例（值）允许进行的操作的集合，包括操作及有关的操作规则是对系统动态特性的描述。</dd>
    <dd>完整性约束条件：数据的完整性约束条件是一组完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</dd>
</dl>

<br/>

10.　试述层次模型的概念，举出三个层次模型的实例。

在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：

有且只有一个节点没有双亲节点，这个节点称为根节点；

根以外的其他节点由且只有一个双亲节点。

<br/>

11.　试述网状模型的概念，举出三个网状模型的实例。

在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：

允许一个以上节点无双亲；

一个节点可以有多余一个的双亲。

<br/>

12.　试述网状、层次数据库的优缺点。

<dl>
    网状数据库的优点主要有：
    <dd>能够更为直观地描述现实世界，如一个节点可以有多个双亲，节点之间可以有多种联系。</dd>
    <dd>具有良好的性能，存取率较高。</dd>
</dl>

<dl>
    网状数据库的缺点主要有：
    <dd>结构比较复杂，而且随着应用环境的扩大，数据库的结构会变得越来越复杂，不利于最终用户掌握。</dd>
    <dd>网状模型的 DDL、DML 复杂，并且要嵌入某一种高级语言中。用户不容易掌握，不容易使用。</dd>
    <dd>由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此用户必须了解系统架构的细节，加重了编写应用程序的负担。</dd>
</dl>

<dl>
    层次数据库的优点主要有：
    <dd>层次模型的数据结构比较简单清晰。</dd>
    <dd>层次模型的查询效率高。因为层次模型中记录之间的联系用有向边表示，这种联系在 DBMS 中常常用指针来实现。因此这种联系也就是记录之间的存取路径。当要存取某个节点的记录值，DBMS 就沿着这一条路径很快找到该记录值，所以层次数据库的性能优于关系数据库，不低于网状数据库。</dd>
    <dd>层次数据模型提供了良好的完整性支持。</dd>
</dl>

<dl>
    层次数据库的缺点主要有：
    <dd>现实世界中很多联系都是非层次的，如节点之间具有多对多联系，不适合用层次模型表示。</dd>
    <dd>如果一个节点具有多个双亲节点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟节点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂。</dd>
    <dd>查询子女节点必须通过双亲节点。</dd>
    <dd>由于结构严密，层次命令趋于程序化。</dd>
</dl>

<br/>

13.　试述关系模型的概念。定义并解释以下术语：

关系，属性，域，元祖，码，分量，关系模式

关系：一个关系对应通常说的一张表。

属性：表中的一列即为一个属性。

域：属性的取值范围。

元祖：表中的一行即为一个元祖。

码：也称码键。表中的某个属性组，它可以唯一确定一个元祖。

分量：元祖中的一个属性值。

关系模式：对关系的描述，一般表示为：关系名（属性 1，属性 2，······，属性 n）。

<br/>

14.　试述关系数据库的特点。

<dl>
    关系模型具有下列优点：
    <dd>关系模型与非关系模型不同，它是建立在严格的数学概念基础上的。</dd>
    <dd>关系模型的概念单一。无论实体还是实体之间的联系都用关系表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单、清晰、用户易懂易用。</dd>
    <dd>关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</dd>
</dl>

<dl>
    关系模型具有下列缺点：
    <dd>由于存取路径对用户是隐蔽的，查询效率往往不如格式化数据模型。</dd>
    <dd>为了提高性能，数据库管理系统必须对用户的查询请求进行优化，因此增加了开发数据库管理系统的难度。不过用户不必考虑这些系统内部的优化技术细节。</dd>
</dl>

<br/>

15.　试述数据库系统的三级模式结构，并说明这种结构的优点是什么。

数据库系统的三级模式结构由外模式、模式、内模式组成。

外模式：亦称子模式或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。

模式：亦称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式涉及的是数据局部逻辑结构，通常的模式的子集。

内模式：亦称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。

<dl>
    三级模式结构的优点：
    <dd>数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留给数据库系统管理，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的表示和存储。为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两层映像：外模式/模式和模式/内模式映像。</dd>
    <dd>正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。</dd>
</dl>

<br/>

16.　定义并解释以下术语：

模式，外模式，内模式，数据定义语言，数据操纵语言

模式：亦称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式涉及的是数据局部逻辑结构，通常的模式的子集。

外模式：外模式：亦称子模式或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。

内模式：内模式：亦称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。

数据定义语言（Data Definition Language，DDL）：用来定义数据库模式、外模式、内模式的语言。

数据操纵语言（Data Manipulation Language，DML）：用来对数据库中的数据进行查询、插入、删除、修改的语言。

<br/>

17.　什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？为什么数据系统具有数据与程序的独立性？

数据与程序的物理独立性：当数据库的存储结构改变时（例如选用了另一种存储结构），由数据库管理员对模式/内模式卓出相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性。

数据与程序的逻辑独立性：当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像做相应改变，可以使外模式保持不变。应用程序是依据数据外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。

数据库管理系统在三级模式之间提供的两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。

<br/>

18.　试述数据库系统的组成。

数据库系统一般由数据库、数据库管理系统（及其应用开发工具）、应用程序、数据库管理员组成。

<dl>
    硬件平台及数据库。由于数据库系统的数据量都很大，加之数据库管理系统丰富的功能使得其自身的规模也很大，因此整个数据库对硬件资源提出了较高的要求：
    <dd>要有足够大的内存，存放操作系统、数据库管理系统的核心模块、数据缓冲区、应用程序。</dd>
    <dd>有足够大的磁盘或磁盘阵列等设备存放数据库，有足够的磁带（或光盘）作数据备份。</dd>
    <dd>要求系统有较高的通道能力，以提高数据传送率。</dd>
</dl>

<dl>
    软件。数据库系统的软件主要包括：
    <dd>数据库管理系统。数据库管理系统是为数据库的建立、使用、维护配置的软件。</dd>
    <dd>支持数据库管理系统运行等操作系统。</dd>
    <dd>具有与数据库接口的高级语言及其编译系统，便于开发应用程序。</dd>
    <dd>以数据库管理系统为核心的应用开发工具。</dd>
    <dd>为特定应用环境开发的数据库应用系统。</dd>
</dl>

<dl>
    人员。开发、管理、使用数据库系统的人员主要是：
    <dd>数据库管理员。</dd>
    <dd>系统分析员。</dd>
    <dd>数据库设计人员。</dd>
    <dd>应用程序员。</dd>
    <dd>最终用户。</dd>
</dl>

<br/>

19.　试述数据库管理员、系统分析员、数据库设计人员、应用程序员的职责。

数据库管理员：负责全面地管理科控制数据库系统。具体职责包括决定数据库的信息内容和结构。决定数据库的存储结构和存储策略。定义数据的安全性要求和完整性约束条件。监控数据库的使用和运行。数据库的改进、重组、重构。

系统分析员：负责应用系统的需求分析和规范说明，要和用户即数据库管理员相结合，确定系统的硬件软件配置，并参与数据库系统的概要设计。

数据库设计人员：负责数据库中数据的确定及数据库各级模式的设计。数据库设计人员必须参加用户需求调查和系统分析，然后进行数据库设计。在很多情况下，数据库设计人员就由数据库管理员担任。

应用程序员：负责设计和编写应用系统的程序模块，并进行调试和安装。

<br/>

### 第 2 章　关系数据库
1.　试述关系数据库的三个组成部分。

关系模式由关系数据结构、关系操作集合、关系完整性约束三部分组成。

关系数据结构：在关系模式中，现实世界的实体以及实体间的各种操作均用单一的结构类型，即用关系来表示。

关系操作集合：关系模型中常用的关系操作包括查询操作和插入、删除、修改操作两大部分。

关系完整性约束：关系模型中有实体完整性约束、参照完整性约束、用户定义的完整性约束三类约束。

<br/>

2.　简述关系数据语言的特点和分类。

特点：都是非过程化的集合操作语言，具有完备的表达能力，功能强，能够嵌入高级语言中使用。

<dl>
    分类：
    <dd>关系代数语言：用对关系的运算来表达查询。</dd>
    <dd>关系演算语言：用谓词来表达查询。</dd>
    <dd>SQL：具有丰富的查询功能，而且具有数据定义和数据控制功能，是集 DDL、DML、DCL 于一体的关系数据语言。</dd>
</dl>

<br/>

3.　定义并理解下列术语，说明它们之间的联系与区别。

（1）域，笛卡尔积，关系，元组，属性；

（2）主码，候选码，外码；

（3）关系模式，关系，关系数据库。

（1）

域：一组具有相同数据类型的值的集合。

笛卡尔积：给定一组域 $D_{1}, \ D_{2}, \ \cdots, \ D_{n}$，允许其中某些域是相同的，$D_{1}, \ D_{2}, \ \cdots, \ D_{n}$ 的笛卡尔积为 $D_{1} \times D_{2} \times \cdots D_{n} = \{(d_{1}, \ d_{2}, \ \cdots, \ d_{n}) \mid d_{i} \in D_{i}, \ i = 1, \ 2, \ \cdots, \ n\}$。

关系：$D_{1}, \ D_{2}, \ \cdots, \ D_{n}$ 的子集叫做在域 $D_{1}, \ D_{2}, \ \cdots, \ D_{n}$ 上的关系，表示为 $R(D_{1}, \ D_{2}, \ \cdots, \ D_{n})$。

元组：关系中的每个元素是关系中的元组。

属性：关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性。

（2）

主码：若一个关系有多个候选码，则选定其中一个为主码。

候选码：若关系中的某一属性组的值能惟一地标识一个元组，而其子集不能，则称该属性组为候选码。

外码：设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的码，$K_{s}$ 是基本关系 $S$ 的主码。如果 $F$ 与 $K_{s}$ 相对应，则称 $F$ 是 $R$ 的外码。

（3）

关系模式：关系的描述称为关系模式。它可以形式化地表示为 $R(U, \ D, \ DOM, \ F)$，其中 $R$ 为关系名，$U$ 为组成该关系的属性名集合，$D$ 为 $U$ 中属性所来自的域，$DOM$ 为属性向域的映像集合，$F$ 为属性间数据的依赖关系集合。

关系：$D_{1}, \ D_{2}, \ \cdots, \ D_{n}$ 的子集叫做在域 $D_{1}, \ D_{2}, \ \cdots, \ D_{n}$ 上的关系，表示为 $R(D_{1}, \ D_{2}, \ \cdots, \ D_{n})$。

关系数据库：关系数据库也有型和值之分。关系数据库也称为关系数据库模式，是对关系数据库的描述。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。

<br/>

4.　举例说明关系模式和关系的区别。

关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。例如，学生关系模式在不同的学年，学生关系是不同的。

<br/>

5.　试述关系模式的完整性规则。在参照完整性中，什么情况下外码属性的值可以为空值？

关系模式的完整性约束规则是对关系的某种约束条件。关系模型中有三类我完整性约束：实体完整性、参照完整性、用户定义的完整性。

实体完整性规则：若属性（指一个或一组属性）$A$ 是基本关系 $R$ 的主属性，则 $A$ 不能取空值。

参照完整性规则：若属性（或属性组）$F$ 基本关系 $R$ 的外码，它与基本关系 $S$ 的主码 $K_{s}$ 相对应（基本关系 $R$ 和 $S$ 不一定是不同的关系），则对于 $R$ 中每个元组在 $F$ 上的值必须取空值或等于 $S$ 中某个元组的主码值。

用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。

在参照完整性中，外码属性的值可以为空值，它表示该属性的值尚未确定，但前提条件是该外码属性不是其所在参照关系的主属性。

<br/>

6.　设有一个 SPJ 数据库，包括 S、P、J 即 SPJ 4 个关系模式。

S(SNO, SNAME, STATUS, CITY)；

P(PNO, PNAME, COLOR, WEIGHT)；

J(JNO, JNAME, CITY)；

SPJ(SNO, PNO, JNO, QTY)。

供应商 S 由供应商代码（SNO）、供应商姓名（SNAME）、供应商状态（STATUS）、供应商所在城市（CITY）组成。

零件表 P 由零件代码（PNO）、零件名（PNAME）、颜色（COLOR）、重量（WEIGHT）组成。

工程项目表 J 由工程项目代码（JNO）、工程项目名（JNAME）、工程项目所在城市（CITY）组成。

供应情况表 SPJ 由供应商代码（SNO）、零件代码（PNO）、工程项目代码（JNO）、供应数量（QTY）组成，表示某供应商供应某种零件给某工程项目的数量为 QTY。

今有若干数据如下：

S 表

| SNO | SNAME | STATUS | CITY |
| - | - | - | - |
| S1 | 精益 | 20 | 天津 |
| S2 | 盛锡 | 10 | 北京 |
| S3 | 东方红 | 30 | 北京 |
| S4 | 丰泰盛 | 20 | 天津 |
| S5 | 为民 | 30 | 上海 |

P 表

| PNO | PNAME | COLOR | WEIGHT |
| - | - | - | - |
| P1 | 螺母 | 红 | 12 |
| P2 | 螺栓 | 绿 | 17 |
| P3 | 螺丝刀 | 蓝 | 14 |
| P4 | 螺丝刀 | 红 | 14 |
| P5 | 凸轮 | 蓝 | 40 |
| P6 | 齿轮 | 红 | 30 |

J 表

| JNO | JNAME | CITY |
| - | - | - |
| J1 | 三建 | 北京 |
| J2 | 一汽 | 长春 |
| J3 | 弹簧厂 | 天津 |
| J4 | 造船厂 | 天津 |
| J5 | 机车厂 | 唐山 |
| J6 | 无线电厂 | 常州 |
| J7 | 半导体厂 | 南京 |

SPJ 表

| SNO | PNO | JNO | QTY |
| - | - | - | - |
| S1 | P1 | J1 | 200 |
| S1 | P1 | J3 | 100 |
| S1 | P1 | J4 | 700 |
| S1 | P2 | J2 | 100 |
| S2 | P3 | J1 | 400 |
| S2 | P3 | J2 | 200 |
| S2 | P3 | J4 | 500 |
| S2 | P3 | J5 | 400 |
| S2 | P5 | J1 | 400 |
| S2 | P5 | J2 | 100 |
| S3 | P1 | J1 | 200 |
| S3 | P3 | J1 | 200 |
| S4 | P5 | J1 | 100 |
| S4 | P6 | J3 | 300 |
| S4 | P6 | J4 | 200 |
| S5 | P2 | J4 | 100 |
| S5 | P3 | J1 | 200 |
| S5 | P6 | J2 | 200 |
| S5 | P6 | J4 | 500 |

试用关系代数、ALPHA 语言、QBE 语言完成如下查询：

（1）求供应工程 J1 零件的供应商号码 SNO；

（2）求供应工程 J1 零件 P1 的供应商号码 SNO；

（3）求供应工程 J1 零件为红色的供应商号码 SNO；

（4）求没有使用天津供应商生产的红色零件的工程项目代码 JNO；

（5）求至少用了供应商 S1 所供应的全部零件的工程项目代码 JNO。

（1）

关系代数：$\pi_{SNO} = (\sigma_{JNO = 'J1'}(SPJ))$。

ALPHA 语言：略。

QBE 语言：略。

（2）

关系代数：$\pi_{SNO} = (\sigma_{JNO = 'J1' \wedge PNO = 'P1'}(SPJ))$。

ALPHA 语言：略。

QBE 语言：略。

（3）

关系代数：$\pi_{SNO}(\pi_{SNO, PNO}(\sigma_{JNO = 'J1'}(SPJ)) \bowtie \pi_{PNO}(\sigma_{COLOR = '红'}(P)))$。

ALPHA 语言：略。

QBE 语言：略。

（4）

关系代数：$\pi_{SNO}(J) - \pi_{JNO}(\pi_{SNO}(\sigma_{CITY = '天津'}(S)) \bowtie \pi_{SNO, PNO, JNO}(SPJ) \bowtie \pi_{PNO}(\sigma_{COLOR = '红'}(P)))$。

ALPHA 语言：略。

QBE 语言：略。

（5）

关系代数：$\pi_{SNO, PNO}(SPJ) \div \pi_{PNO}(\sigma_{SNO = 'S1'}(SPJ))$。

ALPHA 语言：略。

QBE 语言：略。

<br/>

7.　试述等值连接与自然连接的区别和联系。

连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。

$\theta$ 为“$＝$”的连接运算称为等值连接。它是从关系 $R$ 与 $S$ 的广义笛卡尔积中选取 $A$、$B$ 属性值相等的那些元组，即等值连接为 $R \mathop{\bowtie}\limits_{A = B} S = \{ \overset{\frown}{t_{r}t_{s}} \mid t_{r} \in R \wedge t_{s} \in S \wedge t_{r}[A] = t_{s}[B]\}$。

自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。即若 $R$ 和 $S$ 具有相同的属性组 $B$，则自然连接可记作 $R \bowtie S = \{ \overset{\frown}{t_{r}t_{s}}[U - B] \ | \ t_{r} \in R \wedge t_{s} \in S \wedge t_{r}[B] = t_{s}[B]\}$。

一般的连接操作是从行的角度进行运算。但自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。

<br/>

8.　关系代数的基本运算有哪些？如何用这些基本运算来表示其他运算？

关系代数的基本运算有并、差、笛卡尔积、投影、选择。交、连接、除可以用这些基本运算来表示。

交：$R \cap S = R - (R - S)$ 或 $R \cap S = S - (S - R)$；

连接：$R \mathop{\bowtie}\limits_{A \theta B} S = \sigma_{A \theta B}(R \times S)$；

除：$R(X, \ Y) \div S(Y, \ Z) = \pi_{X}(R) - \pi_{X}(\pi_{X}(R) \times \pi_{Y}(S) - R)$；

<br/>

### 第 3 章　关系数据库标准语言 SQL
1.　试述 SQL 的特点。

综合统一：SQL 集数据定义语言、数据操纵语言、数据控制语言的功能于一体。在关系模型中实体和实体间的联系均用关系表示，这种数据结构的单一性带来了数据操作符的统一性，查找、插入、删除、更新等每一种操作都只需一种操作符，从而克服了非关系系统由于信息表示方式的多样性带来的操作复杂性。

高度非过程化：用 SQL 进行数据操作时，只要提出“做什么”，而无需指明“怎么做”，因此无需了解存取路径。存取路径的选择以及 SQL 的操作过程由系统自动完成。这不但大大减轻了用户的负担，而且有利于提高数据独立性。

面向集合的操作方式：SQL 采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。

以同一种语法结构提供多种使用方式：SQL ，既是独立的语言，又是嵌入式语言。作为独立的语言，它能够独立地用于联机交互的使用方式；作为嵌入式语言，它能够嵌入到高级语言程序中，供程序员设计程序时使用。

语言简捷，易学易用。

<br/>

2.　说明在 `DROP TABLE` 时，`RESTRICT `和 `CASCADE` 的区别。

若选择 `RESTRICT`，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如 `CHECK`、`FOREIGN KEY` 等约束），不能有视图，不能有触发器，不能有存储过程或存储函数等。如果存在这些依赖该表的对象，则此表不能被删除。

若选择 `CASCADE`，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。

默认情况是 `RESTRICT`。

<br/>

3.　有两个关系 S(A, B, C, D) 和 T(C, D, E, F)，写出与下列查询等价的 SQL 表达式：

（1）$\sigma_{A = 10}(S)$；（2）$\Pi_{A, B}(S)$；（3）$S \bowtie T$；（4）$S \mathop{\bowtie}\limits_{S.C = T.C} T$；（5）$S \mathop{\bowtie}\limits_{A < E} T$；（6）$\Pi_{C, D}(S) \times T$。

（1）

```SQL
SELECT *
FROM S
WHERE A = 10;
```

（2）

```SQL
SELECT A, B
FROM S;
```

（3）

```SQL
SELECT *
FROM S
INNER JOIN T
ON S.C = T.C AND S.D = T.D;
```

（4）

```SQL
SELECT *
FROM S
INNER JOIN T
ON S.C = T.C;
```

（5）

```SQL
SELECT *
FROM S
INNER JOIN T
ON S.A < T.E;
```

（6）

```SQL
SELECT *
FROM S, T
WHERE S.C = T.C AND S.D = T.D
```

<br/>

4.　用 SQL 语句建立第 2 章习题 6 中的 4 个表；针对建立的 4 个表用 SQL 完成第 2 章习题 6 中的查询。

建表：

建立 S 表：

```SQL
CREATE TABLE S (
    SNO CHAR(2) UNIQUE,
    SNAME CHAR(6),
    STATUS CHAR(6),
    CITY CHAR(4)
);
```

建立 P 表：

```SQL
CREATE TABLE P (
    PNO CHAR(2) UNIQUE,
    PNAME CHAR(6),
    COLOR CHAR(2),
    WEIGHT INT
);
```

建立 J 表：

```SQL
CREATE TABLE P (
    JNO CHAR(2) UNIQUE,
    JNAME CHAR(8),
    CITY CHAR(4)
);
```

建立 SPJ 表：

```SQL
CREATE TABLE P (
    SNO CHAR(2),
    PNO CHAR(2),
    JNO CHAR(2),
    QTY INT
);
```

查询：

求供应工程 J1 零件的供应商号码 SNO：

```SQL
SELECT SNO
FROM SPJ
WHERE JNO = 'J1';
```

求供应工程 J1 零件 P1 的供应商号码 SNO：

```SQL
SELECT SNO
FROM SPJ
WHERE JNO = 'J1' AND PNO = 'p1';
```

求供应工程 J1 零件为红色的供应商号码 SNO：

```SQL
SELECT SNO
FROM SPJ, P
WHERE JNO = 'J1' AND SPJ.PNO = P.PNO AND COLOR = '红';
```

求没有使用天津供应商生产的红色零件的工程项目代码 JNO：

```SQL
SELECT JNO
FROM SPJ
WHERE JNO NOT IN (
    SELECT JNO
    FROM SPJ, P, S
    WHERE S.CITY = '天津' AND COLOR = '红' AND S.SNO = SPJ.SNO AND P.PNO = SPJ.PNO
);
```

求至少用了供应商 S1 所供应的全部零件的工程项目代码 JNO：

```SQL
SELECT DISTINCT JNO
FROM SPJ AS SPJZ
WHERE NOT EXISTS (
    SELECT *
    FROM SPJ AS SPJX
    WHERE SNO = 'S1'
    AND NOT EXISTS (
        SELECT *
        FROM SPJ AS SPJY
        WHERE SPJY.PNO = SPJX.PNO AND SPJY.JNO = SPJZ.JNO AND SPJY.SNO = 'S1'
    )
);
```

<br/>

5.　针对习题 4 中的 4 个表试用 SQL 完成以下各项操作：

（1）找出所有供应商的姓名和所在城市；

（2）找出所有零件的名称、颜色、重量；

（3）找出使用供应商 S1 所供应零件的工程号码；

（4）找出工程项目 J2 使用的各种零件的名称及其数量；

（5）找出上海厂商供应的所有零件号码；

（6）找出使用上海产的零件的工程名称；

（7）找出没有使用天津产的零件的工程号码；

（8）把全部红色零件的颜色改成蓝色；

（9）由 S5 供给 J4 的零件 P6 改为由 S3 供应，请作必要的修改；

（10）从供应商关系中删除 S2 的记录，并从供应情况关系在删除相应的记录；

（11）请将 `(S2, J6, P4, 200)` 插入供应情况关系。

（1）

```SQL
SELECT SNAME, CITY
FROM S;
```

（2）

```SQL
SELECT PNAME, COLOR, WEIGHT
FROM P;
```

（3）

```SQL
SELECT DISTINCT JNO
FROM SPJ
WHERE SNO = 'S1';
```

（4）

```SQL
SELECT PNAME, QTY
FROM SPJ, P
WHERE SPJ.PNO = P.PNO AND SPJ.JNO = 'J2';
```

（5）

```SQL
SELECT PNO
FROM SPJ, S
WHERE SPJ.SNO = S.SNO AND CITY = '上海';
```

（6）

```SQL
SELECT JNAME
FROM SPJ, S, J
WHERE SPJ.SNO = S.SNO AND SPJ.JNO = J.JNO AND S.CITY = '上海';
```

（7）

```SQL
SELECT DISTINCT JNO
FROM SPJ
WHERE JNO NOT IN (
    SELECT DIST JNO
    FROM SPJ, S
    WHERE SPJ.SNO = S.SNO AND S.CITY = '天津'
);
```

（8）

```SQL
UPDATE P
SET COLOR = '蓝'
WHERE COLOR = '红';
```

（9）

```SQL
UPDATE SPJ
SET SNO = 'S3'
WHERE SNO = 'S5' AND PNO = 'P6' AND JNO = 'J4';
```

（10）

```SQL
DELETE FROM S
WHERE SNO = 'S2';
DELETE FROM SPJ
WHERE SNO = 'S2';
```

（11）

```SQL
INSERT INTO SPJ (SNO, PNO, JNO, QTY)
VALUES ('S2', 'J6', 'P4', 200);
```

<br/>

6.　什么是基本表？什么是视图？两者的区别和联系是什么？

基本表：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。一个（或多个）基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。

视图：视图是从一个或几个基本表（或视图）导出的表。它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据，这些数据任存放在导出视图的基本表中，因此视图是一个虚表。

区别：视图本身不独立存储在数据库中，是一个虚表，即数据库中只存放视图的定义而不存放视图对应的数据，这些数据任存放在导出视图的基本表中。

联系：视图在概念上和基本表等同，用户可以如同基本表那样使用视图，可以再视图上定义视图。所以基本表中数据的发生变化，从视图中查询出的数据也就随之发生变化。

<br/>

7.　试述视图的优点。

视图能够简化用户的操作：视图机制使用户可以将注意力集中在所关心的数据上。如果这些数据不是直接来自基本表，则可以通过定义视图使数据库看起来结构简单、清晰，并且可以简化用户的数据查询操作。

视图使用户能以多种角度看待同一数据：视图机制能使不同的用户以不同的方式看待同一数据，当许
多不同种类的用户共享一个数据库时，这种灵活性是非常重要的。

视图对重构数据库提供了一定程度的逻辑独立性：数据的逻辑独立性是指当数据库重构造时，用户的应
用程序不会受影响。

视图能够对机密数据提供安全保护：有了视图机制，就可以在设计数据库应用系统时对不同的用户定义不同的视图，使机密数据不出现在不应看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。

适当利用视图可以更清晰地表达查询。

<br/>

8.　哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。

基本表的行列子集视图一般是可更新的。

若视图的属性来自函数、表达式，则该视图是不可以更新的。

<br/>

9.　请为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）。针对该视图完成下列查询：

（1）找出三建工程项目使用的各个零件代码及其数量；

（2）找出供应商 S1 的供应情况。

创建视图：

```SQL
CREATE VIEW V_SPJ
AS SELECT SNO, PNO, QTY
FROM SPJ
WHERE JNO = (
    SELECT JNO
    FROM J
    WHERE JNAME = '三建'
);
```

（1）

```SQL
SELECT DISTINCT PNO, QTY
FROM V_SPJ;
```

（2）

```SQL
SELECT DISTINCT PNO, QTY
FROM V_SPJ
WHERE SNO = 'S1';
```

<br/>

### 第 4 章　数据库安全性
1.　什么是数据库的安全性？

数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。

<br/>

2.　举例说明对数据库安全性产生威胁的因素。

非授权用户对数据库的恶意存取和破坏。

数据库中重要或敏感的数据被泄露。

安全环境的脆弱性。

<br/>

3.　试述信息安全标准的发展历史，试述 CC 评估保证级划分的基本内容。

TCSEC 是指 1985 年美国国防部正式颁布的《可信计算机系统评估准则》。

在 TCSEC 推出后的 10 年里，不同的国家都开始启动建立在 TCSEC 概念上的评估准则，如欧洲的信息技术安全评估准则（ITSEC）、加拿大的可信计算机产品评估准则（CTCPEC）、美国的信息技术安全联邦标准（FC）草案等。

为满足全球 IT 市场上互认标准化安全评估准则结果的需要，CTCPEC、FC、TCSEC、ITSEC 的发起组织于 1993 年起开始联合行动，解决原标准中概念和技术上的差异，将各自独立的准则集合成一组单一的、能被广泛使用的 IT 安全准则，这一行动被称为 CC 项目。项目发起组织的代表建立了专门的委员会来开发通用准则，历经多次讨论和修订，CC V2.1 版于 1999 年被 ISO 采用为国际标准，2001 年被我国采用为国家标准。

目前 CC 已经基本取代了 TCSEC，成为评估信息产品安全性的主要标准。

CC 提出了目前国际上公认的表述信息技术安全性的结构，即把对信息产品的安全要求分为安全功能要求
和安全保证要求。安全功能要求用以规范产品和系统的安全行为，安全保证要求解决如何正确有效地实施这些功能。安全功能要求和安全保证要求都以“类-子类-组件”的结构表述，组件是安全要求的最小构件块。

CC 的文本由三个部分组成，三个部分·相互依存，缺一不可。

第一部分是简介和一般模型，介绍 CC 中的有关术语、基本概念、一般模型、与评估有关的一些框架。

第二部分是安全功能要求，列出了一系列类、子类、组件。由 11 大类、66 个子类、135 个组件组成。

第三部分是安全保证要求，列出了一系列类、子类、组件，包括 7 大类、26 个子类、74 个组件。根据系统对安全保证要求的支持情况提出了评估保证级，从 EAL1 至 EAL7 共分为 7 级，按保证程度逐渐增高。

<br/>

4.　试述实现数据库安全性控制的常用方法和技术。

用户标识和鉴别：由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供使用数据库管理系统的权限。

存取控制：确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据。

视图机制：为不同的用户定义不同的视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。

审计：把用户对数据库的所有操作自动记录下来放入审计日志中，审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间、内容等。

数据加密：根据一定的算法将原始数据（明文）变换为不可直接识别的格式内容（密文），从而使得不知道解密算法的人无法获知数据的内容。

<br/>

5.　什么是数据库中的自主存取控制方法和强制存取控制方法？

自主存取控制方法：用户对于不同的数据库对象由不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的权限转授给其他用户。自主存取控制非常灵活。

强制存取控制方法：每一个数据对象被强制地标以一定的密级，每一个用户也被授予某一个级
别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。强制存取控制相对比较严格。

<br/>

6.　对下列两个关系模式：

学生（学号，姓名，年龄，性别，家庭住址，班级号）

班级（班级号，班级名，班主任，班长）

使用 `GRANT` 语句完成下列授权功能：

（1）授予用户 U1 对两个表的所有权限，并可给其他用户授权。

（2）授予用户 U2 对学生表具有查看权限，对家庭住址具有更新权限。

（3）将对班级表查看权限授予所有用户。

（4）将对学生表的查询、更新权限授予角色 R1。

（5）将角色 R1 授予用户 U1，并且 U1 可继续授权给其他角色。

（1）

```SQL
GRANT ALL PRIVILIGES
ON 学生, 班级
TO U1 WITH GRANT OPTION;
```

（2）

```SQL
GRANT SELECT, UPDATE(家庭地址)
ON 学生
TO U2;
```

（3）

```SQL
GRANT SELECT
ON 班级
TO PUBLIC;
```

（4）

```SQL
GRANT SELECT, UPDATE
ON 学生
TO R1;
```

（5）

```SQL
GRANT R1
TO U1 WITH GRANT OPTION;
```

<br/>

7.　今有以下两个关系模式：

职工（职工号，姓名，年龄，职务，工资，部门号）

部门（部门员，名称，经理名，地址，电话号）

请用 SQL 的 `GRANT` 和 `REVOKE` 语句（加上视图机制）完成以下授权定义或存取控制功能：

（1）用户王明对两个表有 `SELECT` 权限。

（2）用户李勇对两个表有 `INSERT` 和 `DELETE` 权限。

（3）每个职工只对自己的记录有 `SELECT` 权限。

（4）用户刘星对职工表有 `SELECT` 权限，对工资字段具有更新权限。

（5）用户张新具有修改这两个表的结构的权限。

（6）用户周平具有对两个表的所有权限（读、插、改、删数据），并具有给其他用户授权的权限。

（7）用户杨兰具有从每个部门职工中 `SELECT` 最高工资、最低工资、平均工资的权限，他不能查看每个人的工资。

（1）

```SQL
GRANT SELECT
ON 职工, 部门
TO 王明;
```

（2）

```SQL
GRANT INSERT, DELETE
ON 职工, 部门
TO 李勇;
```

（3）

```SQL
GRANT SELECT
ON 职工
WHEN USER() = NAME TO ALL;
```

（4）

```SQL
GRANT SELECT, UPDATE(工资)
ON 职工
TO 刘星;
```

（5）

```SQL
GRANT ALTER TABLE
ON 职工, 部门
TO 张新;
```

（6）

```SQL
GRANT ALL PRIVILIGES
ON 职工, 部门
TO 周平 WITH GRANT OPTION;
```

（7）

```SQL
CREATE VIEW 部门工资
AS SELECT 部门.名称, MAX(工资), MIN(工资), AVG(工资)
FROM 职工, 部门
WHERE 职工.部门号 = 部门.部门号
GROUP BY 职工.部门号
GRANT SELECT
ON 部门工资
TO 杨兰;
```

<br/>

8.　针对习题 7 中（1）~（7）的每一种情况，撤销各用户所授予的权限。 

（1）

```SQL
REVOKE SELECT
ON 职工, 部门
FROM 王明
```

（2）

```SQL
REVOKE INSERT, DELETE
ON 职工, 部门
FROM 李勇;
```

（3）

```SQL
REVOKE SELECT
ON 职工
WHEN USER() = NAME FROM ALL;
```

（4）

```SQL
REVOKE SELECT, UPDATE
ON 职工
FROM 刘星;
```

（5）

```SQL
REVOKE ALTER TABLE
ON 职工, 部门
FROM 张新;
```

（6）

```SQL
REVOKE ALL PRIVILIGES
ON 职工, 部门
FROM 周平;
```

（7）

```SQL
REVOKE SELECT
ON 部门工资
FROM 杨兰;
DROP VIEW 部门工资;
```

<br/>

9.　解释强制存取控制机制中主体、客体、敏感度标记的含义。

主体：主体是系统中的活动实体，既包括数据库管理系统所管理的实际用户，也包括代表用户的各进程。

客体：客体是系统中的被动实体，受主体操纵，包括文件、基本表、索引、视图等。对于主体和客体，数据库管理系统为它们每个实例（值）指派一个敏感度标记。

敏感度标记：敏感度标记被分成若干级别，例如绝密、机密、可信、公开等。主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级。

<br/>

10.　举例说明强制存取控制机制是如何确定主体能否存取客体的。

略。

<br/>

11.　什么是数据库的审计功能，为什么要提供审计功能？

审计功能：数据库管理系统的审计模块在用户对数据库执行操作的同时把所有操作自动记录到系统的审
计日志中。审计通常是很费时间和空间的，所以数据库管理系统往往都将其作为可选特征，允许数据库管理员根据应用对安全性的要求灵活地打开或关闭审计功能。审计功能一般主要用于安全性要求较高的部门。

提供审计功能的原因：任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能，审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间、内容等。

<br/>

### 第 5 章　数据库完整性
1.　什么是数据库的完整性？

数据库的完整性是指数据的正确性和相容性。数据的正确性是指数据符合现实世界语义、反映当前实际状况的；数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的。

<br/>

2.　数据库的完整性概念与数据库的安全性概念有什么区别和联系？

数据的完整性和安全性是两个既有联系又不尽相同的概念。数据的完整性是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。数据的安全性是保护数据库防止恶意破坏和非法存取。因此，完整性检查和控制的防范对象是不合语义的、不正确的数据，防止它们进入数据库。安全性控制的防范对象是非法用户和非法操作，防止他们对数据库数据的非法存取。

<br/>

3.　什么是数据库的完整性约束条件？

完整性约束条件是指数据库中的数据应该满足的语义约束条件。

完整性约束条件分为六类：静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束。

静态列级约束是对一个列的取值域的说明，包括数据类型的约束：数据的类型、长度、单位、精度等；对数据格式的约束；对取值范围或取值集合的约束；空值的约束；其他约束。

静态元组约束就是规定组成一个元组的各个列之间的约束关系，静态元组约束只局限在单个元组上。

静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束，常见的静态关系约束有：实体完整性约束，参照完整性约束，函数依赖约束。

动态列级约束是修改列定义或列值时应满足的约束条件，包括下面两方面：修改列定义时的约束，修改列值时的约束。

动态元组约束是指修改某个元组的值时需要参照其旧值，并且新旧值之间需要满足某种约束条件。

动态关系约束是加在关系变化前后状态上的限制条件，例如事务一致性、原子性等约束条件。

<br/>

4.　关系数据库管理系统的完整性控制机制应具有哪三方面的功能？

提供定义完整性约束条件的机制。完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件。SQL 标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性。这些完整性一般由 SQL 的数据定义语句来实现。它们作为数据库模式的一部分存入数据字典中。

提供完整性检查的方法。数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。一般在 `INSERT`、`UPDATE`、`DELETE` 语句执行后开始检查，也可以在事务提交时检查。检查这些操作执行后数据库中的数据是否违背了完整性约束条件。

违约处理。数据库管理系统若发现用户的操作违背了完整性约束条件将采取一定的动作，如拒绝（`NO ACTION`）执行该操作或级连（`CASCADE`）执行其他操作，进行违约处理以保证数据的完整性。

<br/>

5.　关系数据库管理系统在实现参照完整性时需要考虑哪些方面？

外码是否可以接受空值。

删除被参照关系元组时的问题，系统可能采取的作法有三种：级联删除、受限删除和置空值删除。

在参照关系中插入元组时的问题，系统可能采取的做法有：受限插入和递归插入。

修改关系中主码的问题。如果需要修改主码值，只能先删除该元组，然后再把具有新主码值的元组插入到关系中。如果允许修改主码，首先要保证主码的唯一性和非空，否则拒绝修改，然后要区分是参照关系还是被参照关系。

<br/>

6.　假设有下面两个关系模式：

职工（职工号，姓名，年龄，职务，工资，部门号），其中职工号为主码；

部门（部门号，名称，经理名，电话），其中部门号为主码。

用 SQL 语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义：

（1）定义每个模式的主码；（2）定义参照完整性；（3）定义职工年龄不得超过 60 岁。

```SQL
CREATE TABLE dept (
    dept_no INT,
    dept_name VARCHAR(10),
    manager_name VARCHAR(10),
    phone_number CHAR(11),
    PRIMARY KEY (dept_no)
);
CREATE TABLE emp (
    emp_no INT,
    emp_name VARCHAR(10),
    age INT CHECK (age <= 60),
    job VARCHAR(10),
    salary DECIMAL(10, 2),
    dept_no INT,
    PRIMARY KEY (dept_no),
    FOREIGN KEY (dept_no) REFERENCES dept (dept_no)
);
```

<br/>

7.　在关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？

当违反实体完整性约束条件时，一般采用的方式是拒绝执行，比如拒绝插入或拒绝修改等。

当违反参照完整性约束条件时，并不都是简单地拒绝执行，有时要根据应用语义执行一些附加的操以保证数据库的正确性。比如拒绝执行，级连操作，设置为空值等。

当违反用户定义的完整性约束条件时，一般采用的方式是拒绝执行。

<br/>

8.　某单位想举行一个小型的联谊会，关系 Male 记录注册的男宾信息，关系 Female 记录注册的女宾信息。建立一个断言，将来宾的人数限制在 50 人以内。（提示，先创建关系 Female 和关系 Male。）

```SQL
CREATE ASSERTION num
CHECK (
    NOT EXISTS (
        SELECT COUNT(*)
        FROM (
            SELECT name
            FROM Male
            UNION ALL
            SELECT name
            FROM Female
        ) > 50
    )
);
```

<br/>

### 第 6 章　关系数据理论
1.　理解并给出下列术语的定义：

函数依赖、部分函数依赖、完全函数依赖、传递依赖、候选码、超码、主码、外码、全码（all-key）、1NF、2NF、3NF、BCNF、多值依赖、4NF。

函数依赖：设 $R(U)$ 是属性集 $U$ 上的关系模式。$X, \ Y$ 是属性集 $U$ 的子集。若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称 $X$ 函数确定 $Y$ 或 $Y$ 函数依赖于 $X$，记作 $X \rightarrow Y$。

部分函数依赖：若 $X \rightarrow Y$，但 $Y$ 不完全函数依赖于 $X$，则称 $Y$ 对 $X$ 部分函数依赖，记作 $X \overset{P}{\rightarrow} Y$。

完全函数依赖：在 $R(U)$ 中，如果 $X \rightarrow Y$，并且对于 $X$ 的任何一个真子集 $Y$，都有 $X' \not\rightarrow Y$，则称 $Y$ 对 $X$ 完全函数依赖，记作 $X \overset{F}{\rightarrow} Y$。

传递依赖：在 $R(U)$ 中，如果 $X \rightarrow Y (Y \not\subseteq X)$，$X \not\rightarrow Y$，$Y \rightarrow Z$，$Z \not\subseteq Y$ 则称 $Z$ 对 $X$ 传递函数依赖。记为 $X \overset{传递}{\rightarrow} Z$。

候选码：设 $K$ 为 $R \langle U, \ F \rangle$ 中的属性或属性组合，若 $K \overset{F}{\rightarrow} U$，则 $K$ 为 $R$ 的候选码。

超码：如果 $U$ 函数依赖于 $K$，即 $K \rightarrow U$，则 $K$ 称为超码。

主码：若候选码多于一个，则选定其中一个为主码。

外码：关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的外部码，也称外码。

全码（all-key）：整个属性组是码，称为全码。

1NF：关系模式 $R$ 的每一个分量是不可再分的数据项。

2NF：若 $R \in 1NF$，且每一个非主属性完全函数依赖于任何一个候选码。

3NF：设关系模式 $R \langle U, \ F \rangle \in 1NF$，若 $R$ 中不存在这样的码 $X$，属性组 $Y$ 及非主属性 $Z (Z \not\subseteq Y)$ 使得 $X \rightarrow Y$，$Y \rightarrow Z$ 成立， $Y \not\rightarrow X$。

BCNF：关系模式 $R \langle U, \ F \rangle \in 1NF$，若 $X \rightarrow Y$ 且 $Y \not\subseteq X$ 时 $X$ 必含有码。

多值依赖：设 $R(U)$ 是属性集 $U$ 上的一个关系模式。$X, \ Y, \ Z$ 是 $U$ 的子集，并且 $Z = U - X - Y$。关系模式 $R(U)$ 中多值依赖 $X \rightarrow\rightarrow Y$ 成立，当且仅当对 $R(U)$ 的任一关系 $r$，给定的一对 $(x, \ z)$ 值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关。

4NF：关系模式 $R \langle U, \ F \rangle \in 1NF$，如果对于 $R$ 的每个非平凡多值依赖 $X \rightarrow\rightarrow Y (Y \not\subseteq X)$，$X$ 都有码。

<br/>

2.　建立一个关于系、学生、班级、学会等诸信息的关系数据库。

描述学生的属性有：学号、姓名、出生年月、系名、班号、宿舍区；

描述班级的属性有：班号、专业名、系名、人数、入校年份；

描述系的属性有：系名、系号、系办公室地点、人数：

描述学会的属性有：学会名、成立年份、地点、人数。

有关语义如下：一个系有若干专业，每个专业每年只招一个班，每个班有若干学生。一个系的学生住在同一 宿舍区。每个学生可参加若干学会，每个学会有若干学生。学生参加某学会有一个入会年份。

请给出关系模式，写出每个关系模式的极小函数依赖集，指出是否存在传递函数依赖，对于函数依赖左部是 多属性的情况，讨论函数依赖是完全函数依赖还是部分函数依赖。

指出各关系的候选码、外部码，并说明是否全码存在。

<dl>
    关系模式：
    <dd>学生：S(Sno, Sname, Sbirth, Dept, Class, Rno)。</dd>
    <dd>班级：C(Class, Pname, Dept, Cnum, Cyear)。</dd>
    <dd>系：D(Dept, Dno, Office, Dnum)。</dd>
    <dd>学会：M(Mname, Myear, Maddr, Mnum)。</dd>
</dl>

<dl>
    极小函数依赖集：
    <dd>学生：Sno -> Sname, Sno -> Sbirth, Sno -> Class, Class -> Dept, Dept -> Rno。由于 Sno -> Dept，而 Dept -> Sno，Dept -> Rno，因此 Sno 和 Rno 之间存在传递函数依赖；由于 Class -> Dept，Dept -> Class，Dept -> Rno，因此 Class 和 Rno 之间存在传递函数依赖；由于 Sno -> Class，Class -> Sno，Class -> Dept，因此 Sno 和 Dept 之间存在传递函数依赖。</dd>
    <dd>班级：Class -> Panme, Class -> Cnum, Class -> Cyear, Panme -> Dept。由于 Class -> Panme，Panme -> Class，Panme -> Dept，因此 Class 和 Dept 之间存在传递函数依赖。</dd>
    <dd>系：Dept -> Dno, Dno -> Dept, Dno -> Office, Dno - > Dnum。Dept 和 Office 之间, Dept 和 Dnum 之间不存在传递函数依赖。</dd>
    <dd>学会：Mname -> Myear, Mname -> Maddr, Mname -> Mnum。不存在传递函数依赖。</dd>
</dl>

<dl>
    候选码、外部码，全码：
    <dd>学生：候选码（Sno）、外码（Dept、Class）、全码（无）</dd>
    <dd>班级：候选码（Class）、外码（Dept）、全码（无）</dd>
    <dd>系：候选码（Class、Dno）、外码（无）、全码（无）</dd>
    <dd>学会：候选码（Mname）、外码（无）、全码（无）</dd>
</dl>

<br/>

3.　试由 Armostrong 公理系统推导出下面三条推理规则。

（1）合并规则：若 $X \rightarrow Z$，$X \rightarrow Y$，则有 $X \rightarrow YZ$。

（2）伪传递规则：由 $X \rightarrow Y$，$WY \rightarrow Z$，有 $WX \rightarrow Z$。

（3）分解规则：$X \rightarrow Y$，$Z \subseteq Y$，有 $X \rightarrow Z$。

（1） 已知 $X \rightarrow Z$，由增广律知 $XY \rightarrow YZ$，又因 $X \rightarrow Y$，可得 $XX \rightarrow XY \rightarrow YZ$，根据传递率得 $X \rightarrow YZ$。

（2）已知 $X \rightarrow Y$，由增广律知 $XW \rightarrow WY$，又因 $WY \rightarrow Z$，可得 $XW \rightarrow WY \rightarrow Z$，根据传递率得 $XW \rightarrow Z$。

（3）已知 $Z \subseteq Y$，由自反律知 $Y \rightarrow Z$，又因 $X \rightarrow Y$，所以由传递率得 $X \rightarrow Z$。

<br/>

4.　关于多值依赖的另一种定义是：

给定一个关系模式 $R(X, \ Y, \ Z)$，其中 $X、Y、Z$ 可以是属性或属性组合。

设 $x \in X$，$y \in Y$，$z \in Z$，$xz$ 在 $R$ 中的像集为 $Y_{xz} = \{r.Y \mid r.X = x \wedge r.Z = z \wedge r \in R\}$

**定义** $R(X, \ Y, \ Z)$ 当且仅当 $Y_{xz} = Y_{xz'}$ 对于每一组 $(x, \ z, \ z')$ 都成立，则 $Y$ 对 $X$ 多值依赖，记作 $X \rightarrow \rightarrow Y$。这里，允许 $Z$ 为空集，在 $Z$ 为空集时，称为平凡的多值依赖。

请证明这里的定义和 6.2.7 节中定义 6.9 是等价的。

设 $Y_{xz} = Y_{xz'}$ 对于每一组 $(x, \ z, \ z')$ 都成立，现证其能推出讲义中的定义的条件：

设 $s, \ t$ 是关系 $r$ 中的两个元组，$S[X] = t[X]$，由新定义的条件可知对于每一个 $z$ 值，对都对应相同的一组 $y$ 值。这样一来，对相同的 $x$ 值，交换 $y$ 值后所得到的元组仍然属于关系 $r$，即讲义中多值依赖的条件成立。

如果讲义定义的条件成立，则对相同的 $x$ 值，交换 $y$ 值后所得的元组仍属于关系 $r$，由于任意性及其对称性，可知每个 $z$ 值对应相同的一组 $y$ 值，所以 $Y_{xz} = Y_{xz'}$ 对于每一组 $(x, \ z, \ z')$ 都成立。

综上所述，二者是等价的。

<br/>

5.　试举出三个多值依赖的实例。

略。

<br/>

6.　有关系模式 $R(A, \ B, \ C, \ D, \ E)$，回答下面各个问题：

（1）若 $A$ 是 $R$ 的候选码，具有函数依赖 $BC \rightarrow DE$，那么在什么条件 $R$ 是 BCNF?

（2）如果存在函数依赖 $A \rightarrow B$，$BC \rightarrow D$，$DE \rightarrow A$，列出 $R$ 的所有码。

（3）如果存在函数依赖 $A \rightarrow B$，$BC \rightarrow D$，$DE \rightarrow A$，$R$ 属于 3NF 还是 BCNF。

略。

<br/>

7.　下面的结论哪些是正确的？哪些是错误的？对于错误的请给出一个反例说明之。

（1）任何一个二目关系是属于 3NF 的。

（2）任何一个二目关系是属于 BCNF 的。

（3）任何一个二目关系是属于 4NF 的。

（4）当且仅当函数依赖 $A \rightarrow B$ 在 $R$ 上成立，关系 $R(A, \ B, \ C)$ 等于其投影 $R_{1}(A, \ B)$ 和 $R_{2}(A, \ C)$ 的连接。 

（5）若 $R.A \rightarrow R.B$，$R.B \rightarrow R.C$，则 $R.A \rightarrow R.C$。

（6）若 $R.A \rightarrow R.B$，$R.A \rightarrow R.C$，则 $R.A \rightarrow R.(B, \ C)$。

（7）若 $R.B \rightarrow R.A$，$R.C \rightarrow R.A$，则 $R.(B, \ C) \rightarrow R.A$。

（8）若 $R.(B, \ C) \rightarrow R.A$，则 $R.B \rightarrow R.A$，$R.C \rightarrow R.A$。 

（1）正确。因为关系模式中只有两个属性，所以无传递。

（2）正确。按照 BCNF 的定义，若 $X \rightarrow Y$，且 $Y$ 不是 $X$ 的子集时，每个决定因素都包含码，对于二目关系决定因素必然包含码。

（3）正确。因为关系模式中只有两个属性，所以无非平凡的多值依赖。

（4）错误。当 $A \rightarrow B$ 在 $R$ 上成立，关系 $R(A, \ B, \ C)$ 等于其投影 $R_{1}(A, \ B)$ 和 $R_{2}(A, \ C)$ 的连接。反之则不然。正确的当且仅当函数依赖 $A \rightarrow\rightarrow B$ 在 $R$ 上成立，关系 $R(A, \ B, \ C)$ 等于其投影 $R_{1}(A, \ B)$ 和 $R_{2}(A, \ C)$ 的连接。

（5）正确。

（6）正确。

（7）正确。

（8）错误。关系模式 $SC(Sno, \ Cno, \ Grade)$，$(Sno, \ Cno) \rightarrow Grade$，但 $Sno \not\rightarrow Grade$，$Cno \not\rightarrow Grade$。

<br/>

8.　证明：

（1）如果 $R$ 是 BCNF 关系模式，则 $R$ 是 3NF 关系模式，反之则不然。

（2）如果 $R$ 是 3NF 关系模式，则 $R$ 一定是 $2NF$ 关系模式。

（1）反证法：设 $R$ 是一个 BCNF，但不是 3NF，则必存在非主属性 $A$ 和候选码 $x$ 以及属性集 $y$，使得 $x \rightarrow y$，$y \rightarrow A$，其中 $A \rightarrow x$，$A \rightarrow y$，$y \rightarrow x$ 不在函数依赖中，这就是说 $y$ 不可能包含 $R$ 的码，但 $y \rightarrow A$ 却成立。根据 BCNF 定义，$R$ 不是 BNCF，与题设矛盾，所以一个 BCNF 一定是 3NF。

（2）反正法：假设 $R$ 中非主属性 $A$ 部分依赖于关键字 $K$，则存在 $k'$ 是 $K$ 的子集，使得 $K' \rightarrow A$，因 $K'$ 是 $K$ 的子集，有 $K \rightarrow K'$，但 $K' \not\rightarrow K$，于是有 $K \rightarrow K'$，$K' \not\rightarrow K$，$K' \rightarrow A$，并且 $A$ 不属于 $K$，因而 $A$ 传递依赖于 $K$，即 $R$ 不属于 3NF，与已知矛盾，所以一个 3NF 一定是 2NF。

<br/>

### 第 7 章　数据库设计
1.　试述数据库设计过程。

按照结构化系统设计的方法，考虑数据库及其应用系统开发全过程，将数据库设计分为以下 6 个阶段：

需求分析阶段：进行数据库设计首先必须准确了解与分析用户需求（包括数据与处理）。需求分析是整
个设计过程的基础，是最困难、最耗费时间的一步。

概念结构设计阶段：概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合、归纳、抽
象，形成一个独立于具体数据库管理系统的概念模型。

逻辑结构设计阶段：逻辑结构设计是将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优
化。

物理设计阶段：物理设计是为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。

数据库实施阶段：在数据库实施阶段，设计人员运用数据库管理系统提供的数据库语言及其宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制和调试应用程序，组织数据入库，并进行试运行。

数据库运行和维护阶段：数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中
必须不断地对其进行评价、调整、修改。

设计一个完善的数据库应用系统往往是上述 6 个阶段的不断反复。

<br/>

2.　试述数据库设计过程中形成的数据库模式。

数据库结构设计的不同阶段形成数据库的各级模式：

在概念设计阶段形成独立于机器特点，独立于各个数据库管理系统产品的概念模式，在本篇中就是 E-R 图；

在逻辑设计阶段将 E-R 图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式，然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的外模式；

在物理设计阶段，根据关系数据库管理系统特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。

<br/>

3.　需求分析阶段的设计自标是什么？调查的内容是什么？

需求分析阶段的设计目标是通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。

调查的内容是“数据”和“处理”，通过调查、收集、分析，获得用户对数据库的如下要求：

信息要求，指用户需要从数据库中获得信息的内容与性质，由信息要求可以导出数据要求，即在数据库中需要存储哪些数据。

处理要求，指用户要完成什么处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机
处理。

安全性与完整性要求。

<br/>

4.　数据字典的内容和作用是什么？

内容：数据字典是系统中各类数据描述的集合。数据字典的内容通常包括数据项、数据结构、数据流、数据存储、处理过程五个部分。其中数据项是组成数据的最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。

作用：数据字典是关于数据库中数据的描述，是在需求分析阶段建立，是下一步进行概念设计的基础，并在数据库设计过程中不断修改、充实、完善。

<br/>

5.　什么是数据库的概念结构？试述其特点和设计策略。

在需求分析阶段所得到的应用需求应该首先抽象为信息世界的结构，然后才能更好、更准确地用某一数据库管理系统实现这些需求。概念结构是信息世界的结构，即概念模型。

<dl>
    特点：
    <dd>能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求，是对现实世界的一个真实模型。</dd>
    <dd>易于理解，从而可以用它和不熟悉计算机的用户交换意见。用户的积极参与是数据库设计成功的关键</dd>
    <dd>易于更改，当应用环境和应用要求改变时容易对概念模型修改和扩充。</dd>
    <dd>易于向关系、网状、层次等各种数据模型转换。</dd>
</dl>

<dl>
    设计策略：
    <dd>自顶向下，即首先定义全局概念结构的框架，然后逐步细化。</dd>
    <dd>自底向上，即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。</dd>
    <dd>逐步扩张，首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构。</dd>
    <dd>混合策略，即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。</dd>
</dl>

<br/>

6.　定义并解释概念模型中以下术语：

实体，实体型，实体集，属性，码，实体-联系图（E-R 图）

实体：客观存在并可以相互区分的事物。

实体型：具有相同属性的实体具有相同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体。

实体集：同型实体的集合。

属性：表中的一列即为一个属性。

码：码就是能唯一标识实体的属性，它是整个实体集的性质，而不是单个实体的性质。

实体联系图（E-R 图）：提供了表示实体型、属性、联系的方法，用来描述现实世界的概念模型。

<br/>

7.　学校中有若干系，每个系有若干班级和教研室，每个教研室有若干教员，其中有的教授和副教授每人各带若干究生，每个班有若干学生，每个学生选修若干课程，每门课可由若干学生选修。请用 E-R 图画出此学校的概念模型。

略。

<br/>

8.　某工厂生产若干产品，每种产品由不同的零件组成，有的零件可用在不同的产品上。这些零件由不同的原材料制成，不同零件所用的材料可以相同。这些零件按所属的不同产品分别放在仓库中，原材料按照类别放在若干仓库中。请用 E-R 图画出此工厂产品、零件、材料、仓库的概念模型。

略。

<br/>

9.　什么是数据库的逻辑结构设计？试述其设计步骤。

数据库的逻辑结构设计就是把概念结构设计阶段设计好的基本 E-R 图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。

<dl>
    设计步骤：
    <dd>将概念结构转换为一般的关系、网状、层次模型。</dd>
    <dd>将转换来的关系、网状、层次模型向特定数据库管理系统支持下的数据模型转换。</dd>
    <dd>对数据模型进行优化。</dd>
</dl>

<br/>

10.　试把习题 7 和习题 8 中的 E-R 图转换为关系模型。

略。

<br/>

11.　试用规范化理论中有关范式的概念分析习题 7 设计的关系模型中各个关系模式的候选码，它们属于第范式？会产生什么更新异常？

略。

<br/>

12.　规范化理论对数据库设计有什么指导意义？

规范化理论为数据库设计人员判断关系模式的优劣提供了理论标准，可用以指导关系数据模型的优化，用来预测模式可能出现的问题，为设计人员提供了自动产生各种模式的算法工具，使数据库设计工作有了严格的理论基础。

<br/>

13.　试述数据库物理设计的内容和步骤。

内容：数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。

<dl>
    步骤：
    <dd>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。</dd>
    <dd>对物理结构进行评价，评价的重点是时间效率和空间效率。</dd>
</dl>

<br/>

14.　数据输入在实施阶段的重要性是什么？如何保证输入数据的正确性？

重要性：数据库是用来对数据进行存储、管理与应用的，因此在实施阶段必须将原有系统中的历史数据输入
到数据库。一般数据库系统中数据量都很大，而且数据来源于部门中的各个不同的单位。数据的组织方式、结构、格式都与新设计的数据库系统有相当的差距，组织数据录入就要将各类源数据从各个局部应用中抽取出来，分类转换，最后综合成符合新设计的数据库结构的形式，输入数据库。因此这样的数据转换、组织入库的工作是相当费力费时的工作。特别是原系统是手工数据处理系统时，各类数据分散在各种不同的原始表格、凭证、单据之中，在向新的数据库系统中输入数据是还要处理大量的纸质文件，工作量就更大。

保证输入数据正确性：为提高数据输入工作的效率和质量，应该针对具体的应用环境设计一个数据录入子系统，由计算机来完成数据入库的任务。在源数据入库之前要采用多种方法对其进行检验，以防止不正确的数据入库。

<br/>

15.　什么是数据库的再组织和重构造？为什么要进行数据库的再组织和重构造？

数据库的再组织：指按原设计要求重新安排存储位置、回收垃圾、减少指针链等，以提高系统性能。

数据库的重构造：指部分修改数据库的模式和内模式，即修改原设计的逻辑和物理结构。数据库的再组织是不修改数据库的模式和内模式的。

进行数据库的再组织和重构造的原因：数据库运行一段时间后，由于记录不断增、删、改，会使数据库的物理存储情况变坏，降低了数据的存取效率，数据库性能下降，这时数据库管理员就要对数据库进行重组织。数据库管理系统一般都提供用于数据再组织和重构造的实用程序。数据库应用环境常常发生变化，如增加新的应用或新的实体，取消了某些应用，有的实体与实体间的联系也发生了变化等，使原有的数据库设计不能满足新的需求，需要调整数据库的模式和内模式，这就要进行数据库再组织和重构造。

<br/>

### 第 8 章　数据库编程
1.　使用嵌入式 SOL 对学生-课程数据库中的表完成下述功能：
（1）查询某一门课程的信息。要查询的课程由用户在程序运行过程中指定，放在主变量中。

（2）查询选修某一门课程的选课信息，要查询的课程号由用户在程序运行过程中指定，放在主变量中，然后根据用户的要求修改其中某些记录的成绩字段。

略。

<br/>

2.　对学生-课程数据库编写存储过程，完成下述功能：
（1）统计离散数学的成绩分布情况，即按照各分数段统计人数。

（2）统计任意一门课的平均成绩。

（3）将学生选课成绩从百分制改为等级制（即 A、B、C、D、E）。

略。

<br/>

3.　使用 ODBC 编写应用程序来对异构数据库进行各种数据操作。

配置两个不同的数据源，编写程序连接两个不同的关系数据库管理系统的数据源，对异构数据库进行操作。例如，将 KingbaseES 数据库的某个表中的数据转移到 SQL Server 数据库的表中。

略。

<br/>

### 第 9 章　关系查询处理和查询优化
1.　试述查询优化在关系数据库系统中的重要性和可能性。

重要性：关系系统的查询优化既是关系数据库管理系统实现的关键技术，又是关系系统的优点所在。它减轻了用户选择存取路径的负担。用户只要提出“干什么”，不必指出“怎么干”。查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较高的查询效率，而且在于系统可以比用户程序的“优化”做得更好。

<dl>
    可能性：
    <dd>优化器可以从数据字典中获取许多统计信息，例如关系中的元组数、关系中每个属性的分布情况、哪些属性上是否有索引等。优化器可以根据这些信息做出正确的估算，选择高效的执行计划，而用户程序则难以获得这些信息。</dd>
    <dd>如果数据库的物理统计信息改变了，系统可以自动对查询进行重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。</dd>
    <dd>优化器可以考虑数百种不同的执行计划，而程序员一般只能考虑有限的几种可能性。</dd>
    <dd>优化器中包括了很多复杂的技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。</dd>
</dl>

<br/>

2.　假设关系 $R(A, \ B)$ 和 $S(B, \ C, \ D)$ 情况如下：$R$ 有 20000 个元组，$S$ 有 1200 个元组，一个块能装 40 个 $R$ 的元组，能装 30 个 $S$ 的元组，估算下列操作需要多少次磁盘块读写。

（1）$R$ 上没有索引，`select * from R;`；

（2）$R$ 中 $A$ 为主码，$A$ 有 3 层 B+ 树索引，`select * from R where A = 10;`；

（3）套循环连接 $R \bowtie S$；

（4）排序合并连接 $R \bowtie S$，区分 $R$ 与 $S$ 在 $B$ 属性上已经有序和无序两种情况。

略。

<br/>

3.　对学生课程数据库，查询信息系学生选修了的所有课程名称。

```SQL
SELECT Cname
FROM Student, Course, SC
WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno AND Student.Sdept = 'IS';
```

试画出用关系代数表示的语法树，并用关系代数表达式优化算法对原始的语法树进行优化处理，画出优化后的标准语法树。

略。

<br/>

4.　对于下面的数据库模式

Teacher(Tno, Tname, Tage, Tsex)；Department(Dno, Dname, Trio）；Work（Tno, Dno, Year, Salary)

假设 Teacher 的 Tno 属性、Department 的 Dno 属性以及 Work 的 Year 属性上有 B+ 树索引，说明下列查询语句的一种较优的处理方法。

（1）`select * from teacher where Tsex = '女';`

（2）`select * from department where Dno < 301;`
 
（3）`select * from work where Year <> 2000;`

（4）`select * from work where year > 2000 and salary < 5000;`

（5）`select * from work where year < 2000 or salary < 5000;`

略。

<br/>

5.　对于题 4 中的数据库模式，有如下的查询：

```SQL
select Tname
from teacher, department, work
where teacher.tno = work.tno and department.dno = work.dno and
department.dname='计算机系' and salary > 5000;
```

画出语法树以及用关系代数表示语法树，并对关系代数语法树进行优化，画出优化后的语法树。

略。

<br/>

6.　试述关系数据库管理系统查询优化的一般准则。

选择运算应尽可能先做。

投影运算和选择运算同时进行。

投影同其前或其后的双目运算结合起来。

某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算。

找出公共子表达式。

选取合适的连接算法。

<br/>

7.　试述关系数据库管理系统查询优化的一般步骤。

把查询转换成某种内部表示，通常用的内部表示是语法树。

把语法树转换成标准（优化）形式，即利用优化算法，把原始的语法树转换成优化的形式。

选择低层的存取路径。

生成查询计划，选择代价最小的。

<br/>

### 第 10 章　数据库恢复技术
1.　试述事务的概念及事务的 4 个特性。恢复技术能保证事务的哪些特性？

事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

<dl>
    事务具有 4 个特性：原子性、一致性、隔离性、持续性。这 4 个特性简称为 ACID 特性。
    <dd>原子性：事务是数据库的逻辑工作单位，事务中的操作要么都做，要么都不做。</dd>
    <dd>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。</dd>
    <dd>隔离性：一个事务的执行不能被其他事务扰，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</dd>
    <dd>持续性：持续性也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</dd>
</dl>

恢复技术保证了事务的原子性、一致性、持续性。

<br/>

2.　为什么事务非正常结束时会影响数据库数据的正确性？请举例说明之。

事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如，某公司在银行中有 A，B 两个账号，现在公司想从账号 A 中取出一万元，存入账号 B。那么就可以定义一个事务，该事务包括两个操作，第一个操作是从账号 A 中减去一万元，第二个操作是向账号 B 中加入一万元。这两个操作要么全做，要么全不做。全做或者全不做，数据库都处于一致性状态。如果只做一个操作，则逻辑上就会发生错误，减少或增加一万元，这时数据库就处于不一致性状态了。

<br/>

3.　登记日志文件时为什么必须先写日志文件，后写数据库？

把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能
在这两个操作之间发生故障，即这两个写操作只完成了一个。如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，在恢复时只不过是多执行一次不必要的 UNDO 操作，并不会影响数据库的正确性。所以为了安全，一定要先写日志文件，即首先把日志记录写到日志文件中，然后进行数据库的修改。这就是“先写日志文件”的原则。

<br/>

4.　考虑下图所示的日志记录：

| 序号 | 日志 |
| - | - |
| 1 | $T_{1}$：开始 |
| 2 | $T_{1}$：写 $A = 10$ |
| 3 | $T_{2}$：开始 |
| 4 | $T_{2}$：写 $B, \ B = 9$ |
| 5 | $T_{1}$：写 $C, \ C = 11$ |
| 6 | $T_{1}$：提交 |
| 7 | $T_{2}$：写 $C, \ C = 13$ |
| 8 | $T_{3}$：开始 |
| 9 | $T_{3}$：写 $A, \ A = 8$ |
| 10 | $T_{2}$：回滚 |
| 11 | $T_{3}$：写 $B, \ B = 7$ |
| 12 | $T_{4}$：开始 |
| 13 | $T_{3}$：提交 |
| 14 | $T_{4}$：写 $C, \ C = 12$|

（1）如果系统故障发生在 14 之后，说明哪些事务需要重做，哪些事务需要回滚。

（2）如果系统故障发生在 10 之后，说明哪些事务需要重做，哪些事务需要回滚。
 
（3）如果系统故障发生在 9 之后，说明哪些事务需要重做，哪些事务需要回滚。

（4）如果系统故障发生在 7 之后，说明哪些事务需要重做，哪些事务需要回滚。

（1）需要重做的事务有：$T_{1}, \ T_{2}, \ T_{3}$，需要回滚的事务有：$T_{4}$。

（2）需要重做的事务有：$T_{1}, \ T_{2}$，需要回滚的事务有：$T_{3}$。

（3）需要重做的事务有：$T_{1}$，需要回滚的事务有：$T_{2}, \ T_{3}$。

（4）需要重做的事务有：$T_{1}$，需要回滚的事务有：$T_{2}$。

<br/>

5.　考虑题 4 所示的口志记录，假设开始时 $A、B、C$ 的值都是 0：

（1）如果系统故障发生在 14 之后，写出系统恢复后 $A、B、C$ 的值；

（2）如果系统故障发生在 12 之后，写出系统恢复后 $A、B、C$ 的值；

（3）如果系统故障发生在 10 之后，写出系统恢复后 $A、B、C$ 的值；

（4）如果系统故障发生在 9 之后，写出系统恢复后 $A、B、C$ 的值；

（5）如果系统故障发生在 7 之后，写出系统恢复后 $A、B、C$ 的值；

（6）如果系统故障发生在 5 之后，写出系统恢复后 $A、B、C$ 的值。

（1）$A = 8、B = 7、C = 11$。

（2）$A = 8、B = 9、C = 11$。

（3）$A = 10、B = 9、C = 11$。

（4）$A = 10、B = 9、C = 13$。

（5）$A = 10、B = 9、C = 11$。

（6）$A = 10、B = 7、C = 0$。

<br/>

6.　针对不同的故障，试给出恢复的策略和方法。（即如何进行事务故障的恢复，如何进行系统故障的恢复，以及如何进行介质故障的恢复。）

<dl>
    事务故障的恢复是由系统自动完成的，对用户是透明的。系统恢复的步骤是：
    <dd>反向扫描文件日志（即从后向前扫描日志文件），查找该事务的更新操作。</dd>
    <dd>对该事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。</dd>
    <dd>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</dd>
    <dd>如此处理下去，直至读到此事务的开始标记，该事务故障的恢复就完成了。</dd>
</dl>

<dl>
    系统故障的恢复操是由系统在重新启动时自动完成的，不需要用户干预。系统恢复的步骤是：
    <dd>正向扫描日志文件（即从头扫描日志文件），找出在故障发生前已经提交的事务，将其事务标识记入重做队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撤销队列。</dd>
    <dd>对撤销队列中的各个事务进行撤销处理。</dd>
    <dd>对重做队列中的各个事务进行重做处理。</dd>
</dl>

<dl>
    介质故障发生后，磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障。恢复方法是重装数据库，然后重做已完成的事务。
    <dd>装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。</dd>
    <dd>装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。</dd>
</dl>

<br/>


7.　什么是检查点记录？检查点记录包括哪些内容？

检查点记录是一类新的日志记录。

检查点记录的内容包括：

建立检查点时刻所有正在执行的事务清单。

这些事务的最近一个日志记录的地址。

<br/>

8.　具有检查点的恢复技术有什么优点？试举一个具体例子加以说明。

在采用检查点技术之前，利用日志技术进行数据库的恢复时需要从头扫描日志文件，而利用检查点技术只需要从检查点所处时间点起开始扫描日志，这就缩短了扫描日志的时间，改善恢复效率。例如当事务 T 在一个检查点之前提交，T 对数据库所做的修改都已写入数据库，写入时间是在这个检查点建立之前或在这个检查点建立之时。这样，在进行恢复处理时，没有必要对事务 T 执行重做操作。

<br/>

9.　试述使用检查点方法进行恢复的步骤。

从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一
个检查点记录。

由该检查点记录得到检查点建立时刻所有正在执行的事务清单 ACTIVE-LIST。

<dl>
    这里需要建立以下两个事务队列：
    <dd>UNDO-LIST：需要执行 UNDO 操作的事务集合。</dd>
    <dd>REDO-LIST：需要执行 REDO 操作的事务集合。</dd>
</dl>

把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列，REDO 队列暂时为空。

<dl>
    从检查点开始正向扫描日志文件。
    <dd>如果有新开始的事务，则将其暂时放入 UNDO-LIST 队列。</dd>
    <dd>如果有已提交的事务，则将其从 UNDO-LIST 队列移到 REDO-LIST 队列，直到日志文件结束。</dd>
</dl>

对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST 中的每个事务执行 REDO 操作。

<br/>

10.　什么是数据库镜像？它有什么用途？

数据库镜像即根据数据库管理员的要求，自动把整个数据库或者其中的部分关键数据复制到另一个磁盘上，每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据与主数据库的一致性。

用途：

用于数据库恢复。当出现介质故障时，可由镜像磁盘继续提供使用，同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复，不需要关闭系统和重装数据库副本。

提高数据库的可用性。在没有出现故障时，当一个用户对某个数据加排他锁修改数据时，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁。

<br/>

### 第 11 章　并发控制
1.　在数据库中为什么要并发控制 ？并发控制技术能保证事务的哪些特性？

数据库是一个共享资源，可以供多个用户使用。在这样的系统中，在同一时刻并发运行的事务数可达数百上千个。当多个用户并发地存取数据库时就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏事务的的一致性和数据库的一致性。所以数据库管理系统必须提供并发控制机制。

并发控制技术可以保证事务的一致性和隔离性，保证数据库的一致性。

<br/>

2.　并发操作可能会产生哪几类数据不一致？用什么方法可以避免各种不一致的情况？

并发操作带来的数据不一致性包括三类丢失修改、不可重复读、读“脏”数据。

丢失修改。两个事务 $T_{1}$ 和 $T_{2}$ 读入同一数据并修改，$T_{2}$ 提交的结果破坏了 $T_{1}$ 提交的结果，导致 $T_{1}$ 的修改被丢失。

不可重复读。不可重复读是指事务 $T_{1}$ 读取数据后，事务 $T_{2}$ 执行更新操作，使 $T_{1}$ 无法再现前一次读取结果。

读“脏”数据。读“脏”数据是指事务 $T_{1}$ 修改某一数据并将其写回磁盘，事务 $T_{2}$ 读取同一数据后，$T_{1}$ 由于某种原因被撤销，这时被 $T_{1}$ 修改过的数据恢复原值， $T_{2}$ 读到的数据就与数据库中的数据不一致，则 $T_{2}$ 读到的数据就为“脏”数据，即不正确的数据。

产生上述三类数据不一致性的主要原因是并发操作破坏了事务的隔离性。并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。

<br/>

3.　什么是封锁？基本的封锁类型有几种？试述它们的含义。

封锁是指事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其他事务不能更新此数据对象。

基本的封锁类型有两种：排他锁（exclusive locks，简称 X 锁）和共享锁（share locks，简称 S 锁）。

排他锁又称为写锁。若事务 T 对数据对象 A 加上 X 锁，则只允许 T 来读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁为止。这就保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。

共享锁又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到事务 T 释放 A 上的 S 锁为止。这就保证了其他事务可以读 A，但在事务 T 释放 A 上的 S 锁之前不能对 A 做任何修改。

<br/>

4.　如何用封锁机制保持数据的一致性？

数据库管理系统在对数据进行读、写操作之前首先对该数据执行封锁操作。数据库管理系统按照一定的封锁协议，对并发操作进行控制，使得多个并发操作有序地执行，避免了丢失修改、不可重复读、读“脏”数据等数据不一致性。

<br/>

5.　什么是活锁？试述活锁产生的原因和解决办法。

如果事务 $T_{1}$ 封锁了数据 $R$，事务 $T_{2}$ 又请求封锁 $R$，于是 $T_{2}$ 等待；$T_{3}$ 也请求封锁 $R$，当 $T_{1}$ 释放了 $R$ 上的封锁之后系统首先批准了 $T_{3}$ 的请求，$T_{2}$ 仍然等待；然后 $T_{4}$ 又请求封锁 $R$，当 $T_{3}$ 释放了 $R$ 上的封锁之后系统又批准了 $T_{4}$ 的请求······ $T_{2}$ 有可能永远等待，这就是活锁的情形。

产生的原因：当一系列封锁不能按照其先后顺序执行时，可能导致一些事务无限期地等待某个封锁，从而导致活锁。

解决办法：避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。

<br/>

6.　什么是死锁？请给出预防死锁的若干方法。

如果事务 $T_{1}$ 封锁了数据 $R_{1}$，$T_{2}$ 封锁了数据 $R_{2}$，然后 $T_{1}$ 又请求封锁 $R_{2}$，因 $T_{2}$ 已封锁了 $R_{2}$，于是 $T_{1}$ 等待 $T_{2}$ 释放 $R_{2}$ 上的锁；接着 $T_{2}$ 又请求封锁 $R_{1}$，因 $T_{1}$ 已封锁了 $R_{1}$，$T_{2}$ 也只能等待 $T_{1}$ 释放 $R_{1}$ 上的锁。这样就出现了 $T_{1}$ 在等待 $T_{2}$，而 $T_{2}$ 又在等待 $T_{1}$ 的局面，$T_{1}$ 和 $T_{2}$ 两个事务永远不能结束，形成死锁。

预防死锁的方法：

一次封锁法：要求每个事务必须一次将所用的所有数据全部加锁，否则就不能执行。

顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实行封锁。但是，预防死锁的策略不大适合数据库系统的特点。

<br/>

7.　请给出检测死锁发生的一种方法，当发生死锁后如何解除死锁？

数据库系统一般采用允许死锁发生，数据库管理系统检测到死锁后加以解除的方法。数据库管理系统中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。

超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显，一是有可能误判死锁，如事务因其他原因而使等待时间超过时限，系统会误认为发生了死锁；二是时限若设置得太长，死锁发生后不能及时发现。

事务等待图法：事务等待图是一个有向图 $G = (T, \ U)$。$T$ 为结点的集合，每个结点表示正运行的事务；$U$ 为边的集合，每条边表示事务等待的情况。若 $T_{1}$ 等待 $T_{2}$，则在 $T_{1}、T_{2}$ 之间划一条有向边，从 $T_{1}$ 指向 $T_{2}$。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地（比如每隔数秒）生成事务等待图，并进行检测。如果发现图中存在回路，则表示系统中出现了死锁。

数据库管理系统的并发控制子系统一旦检测到系统真中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有锁，使其他事务得以继续运行下去。对撤销的事务所执行的数据修改操作必须加以恢复。

<br/>

8.　什么样的并发调度是正确的调度？

可串行化的调度是正确的调度。

<br/>

9.　设 $T_{1}、T_{2}、T_{3}$ 是如下的三个事务，设 $A$ 的初值为 0。

$T_{1}$：$A := A + 2$；

$T_{2}$：$A := A * 2$；

$T_{3}$：$A := A ** 2$；（即 $A \leftarrow A^{2}$）

（1）若这三个事务允许并发执行，则有多少种可能的正确结果？请一一列举出来。

（2）请给出一个可串行化的调度，并给出执行结果。

（3）请给出一个非串行化的调度，并给出执行结果。

（4）若这三个事务都遵守两段锁协议，请给出一个不产生死锁的可串行化调度。

（5）若这三个事务都遵守两段锁协议，请给出一个产生死锁的调度。

（1）略。

（2）略。

（3）略。

（4）略。

（5）略。

<br/>

10.　今有三个事务的一个调度 $r_{3}(B)r_{1}(A)w_{3}(B)r_{2}(B)r_{2}(A)w_{2}(B)r_{1}(B)w_{1}(A)$，该调度是冲突可串行化的调度吗？为什么？

该调度是冲突可串行化的调度。

$Sc1 = r_{3}(B)r_{1}(A)w_{3}(B)r_{2}(B)r_{2}(A)w_{2}(B)r_{1}(B)w_{1}(A)$

交换 $r_{1}(A)$ 和 $w_{3}(B)$ 得 $r_{3}(B)w_{3}(B)r_{1}(A)r_{2}(B)r_{2}(A)w_{2}(B)r_{1}(B)w_{1}(A)$

再交换 $r_{1}(A)$ 和 $r_{2}(B)r_{2}(A)w_{2}(B)$ 得 $Sc2 = r_{3}(B)w_{3}(B)r_{2}(B)r_{2}(A)w_{2}(B)r_{1}(A)r_{1}(B)w_{1}(A)$

因为 $Sc2$ 是一个串行调度，因此该调度是冲突可串行化的调度。

<br/>

11.　试证明若并发事务遵守两段锁协议，则对这些事务的并发调度是可串行化的。

略。

<br/>

12.　举例说明对并发事务的一个调度是可串行化的，而这些并发事务不一定遵守两段锁协议。

略。

<br/>

13.　考虑如下的调度，说明这些调度集合之间的包含关系。

（1）正确的调度。

（2）可串行化的调度。

（3）遵循两阶段封锁（2PL）的调度。

（4）串行调度。

（3）遵循两阶段封锁（2PL）的调度 $\subset$（2）可串行化的调度 $\subset$（4）串行调度 $\subset$（1）正确的调度。

<br/>

14.　考虑 $T_{1}$ 和 $T_{2}$ 两个事务。

$T_{1}$：$R(A)$；$R(B)$；$B = A + B$；$W(B)$

$T_{2}$：$R(B)$；$R(A)$；$A = A + B$；$W(A)$

（1）改写 $T_{1}$ 和 $T_{2}$，增加加锁操作和解锁操作，并要求遵循两阶段封锁协议。

（2）说明 $T_{1}$ 和 $T_{2}$ 的执行是否会引起死锁，给出 $T_{1}$ 和 $T_{2}$ 的一个调度并说明之。

（1）

| $T_{1}$ | $T_{2}$ |
| - | - |
| Slock A | |
| R(A) | |
| Slock B | |
| R(B) | |
| Xlock B | |
| B = A + B | |
| W(B) | |
| Ulock B | |
| | Slock B |
| | R(B) |
| Ulock B | |
| Ulock A | |
| | Slock A |
| | R(A) |
| | Xlock A |
| | A = A + B |
| | W(A) |
| | Ulock A |
| | Ulock A |
| | Ulock B |

（2）

| $T_{1}$ | $T_{2}$ |
| - | - |
| Slock A | |
| R(A) | |
| | Slock B |
| | R(B) |
| Slock B | |
| R(B) | |
| Slock B | |
| 等待 | Slock A |
| 等待 | R(A) |
| 等待 | Xclock A |
| | 等待 |

<br/>

15.　为什么要引进意向锁？意向锁的含义是什么？

引进意向锁是为了提高封锁子系统的效率，封锁子系统支持多种封锁粒度。原因是在多粒度封锁方法中一个数据对象可能以两种方式加锁，显式封锁和隐式封锁。在对某个数据对象加锁，系统要检查该数据对象上有无显式封锁与之冲突；再检查其所有上级结点，看本事务的显式封锁是否与该数据对象上的隐式封锁（即由于上级结点已加的封锁造成的）冲突；还要检查其所有下级结点，看它们的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突。显然，这样的检查方法效率很低，为此人们引进了一种新型锁，称为意向锁。

含义：如果对一结点加意向锁，则说明该结点的下层结点正在被加锁；对任一节点加锁时，必须先对它的上层结点加意向锁。

<br/>

16.　试述常用的意向锁：IS 锁、IX 锁、SIX 锁，给出这些锁的相容矩阵。

IS 锁：如果对一个数据对象加 IS 锁，表示它的后裔结点拟（意向）加 S 锁。例如，事务 $T_{1}$ 要对 $R_{1}$ 中某个元组加 S 锁，则要首先对关系 $R_{1}$ 和数据库加 IS 锁。

IX 锁：如果对一个数据对象加 IX 锁，表示它的后裔结点拟（意向）加 X 锁。例如，事务 $T_{1}$ 要对 $R_{1}$ 中某个元组加 X 锁，则要首先对关系 $R_{1}$ 和数据库加 IX 锁。

SIX 锁：如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即 SIX ＝ S ＋ IX。例如对某个表加 SIX 锁，则表示该事务要读整个表（所以要对该表加 S 锁），同时会更新个别元组（所以要对该表加 IX 锁）。

| $T_{1} \ / \ T_{2}$ | S | X | IS | IX | SIX | - |
| - | - | - | - | - | - | - |
| **S** | Y | N | Y | N | N | Y |
| **X** | N | N | N | N | N | Y |
| **IS** | Y | N | Y | Y | Y | Y |
| **IX** | N | N | Y | Y | N | Y |
| **SIX** | N | N | Y | N | N | Y |
| **-** | Y | Y | Y | Y | Y | Y |

<br/>

### 第 12 章　数据库管理系统
1.　试述数据库管理系统的基本功能。

数据库定义和创建。创建数据库主要是用数据定义语言定义和创建数据库模式、外模式、内模式等数据库对象。

数据组织、存储和管理。数据库管理系统要分类组织、存储、管理各种数据，包括数据字典、用户数据、存取路径等。

数据存取。数据库管理系统提供用户对数据的操作功能，实现对数据库数据的检索、插入、修改、删除。

数据库事务管理和运行管理。数据库管理系统运行控制和管理功能。这些功能保证了数据库系统的正常运行，保证了事务的 ACID 特性。

数据库的建立和维护。包括数据库的初始建立、数据的转换、数据库的转储和恢复、数据库的重组织和重构造、性能监测分析等功能。

其他功能。包括与网络中其他软件系统的通信功能；一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能；异构数据库之间的互访和互操作功能等。

<br/>

2.　关系数据库管理系统的工作过程是什么？给出数据库管理系统插入一个记录的活动过程，画出活动过程示意图。

用户通过应用程序向数据库管理系统（以 RDBMS 为例）发出调用数据库数据的 `INSERT` 命令。在命令中给出一个关系名和所插入的元组值。

数据库管理系统先对命令进行语法检查、语义检查、用户存取权限检查。语义检查的具体做法是，数据库管理系统读取数据字典，检查是否存在该关系及相应的字段，值的数据类型是否正确，检查该用户是否具有该关系上执行 `INSERT` 操作的权限。若未能通过检查就拒绝执行 `INSERT` 命令，返回有关的错误提示信息。

数据库管理系统查看存储模式，找到新记录所应插入的位置和相应的页面 P。

数据库管理系统在系统缓冲区中找到一个空页。

数据库管理系统根据第三步的执行结果，向操作系统发出读取物理页而 P 的命令。

操作系统执行读操作。将数据页 P 读入系统缓冲区中的空白页处。

数据库管理系统根据插入命令和数据字典的内容将数据转化成内部记录的格式。

数据库管理系统将数据记录写入系统缓冲区的页面 P 中。

数据库管理系统将执行事务的提交。把状态信息（如成功或不成功的指示）、例外状态信息等返回给应用程序。（这里未考虑多用户并发控制的问题）

<br/>

3.　关系数据库管理系统的语言处理层是如何处理一个数据定义语言语句的？

关系数据库管理系统首先对语句进行语法检查，检查通过后进行语义检查和用户存取权限检查。具体做法是，关系数据库管理系统读取数据字典，检查是否存在与该关系即相应的字段、该用户能否读取它们等，确认语义正确、存取权限合法后便决定执行该命令，否则拒绝执行，返回错误信息。

关系数据库管理系统执行优化查询。优化器依据数据字典中的信息进行优化，并把该命令转换成一串单记录的存取操作序列。

<br/>

4.　试述关系数据库管理系统的语言处理层处理一个数据操纵语言语句的大致过程。

先对数据操纵语句进行词法分析和语法分析，并把外部关系名、属性名转换为内部名，通过词法和语法
分析后生成语法分析树。

根据数据字典中的内容进行查询检查，包括审核用户的存取权限和完整性检查。

对查询进行优化，优化分为两类，一类为代数优化，另一类为存取路径优化。

把选中的查询执行方案描述出来。

<br/>

5.　什么是处理数据操纵语言语句的解释方法和预编译方法？试述二者的区别、联系，比较各自的优缺点。

解释方法的具体做法是直到执行前，数据操纵语句都以原始字符串的形式保存，当执行到该语句时，才利用解释程序去完成全部过程，同时予以执行。这种方法通过尽量推迟束缚过程来赢得数据独立性。解释方法具有灵活、应变性强的优点，甚至能适应在解释过程中发体的数据结构、存储结构等的变化，因此能保持较高
的数据独立性。但由于每次执行一个数据操纵语句时都要执行所有步骤，尤其当这样的语句位于一个循环体内时，就要多次重复解释一个数据操纵语句，开销会很大，因此效率比较低。

预编译方法的基本思想是在用户提交数据操纵语句之后，在运行之前对它进行翻译处理，保存产生好的可执
行代码。当需要运行时，取出保存的可执行代码加以执行。自动重编译技术使得预编译方法既拥有了编译时进行束缚所带来的高效率，又具备了执行时束缚带来的数据独立性。使用这种方法会遇到这样的问题：在束缚过程中进行优化所依据的条件可能在运行前已不存在，或者数据库结构已被修改，因而导致已作出的应用规划在执行时不再有效。

<br/>

6.　试述数据存取层主要的了系统及其功能。

记录存取、事务管理子系统。

控制信息管理模块。

排序/合并子系统。

存取路径维护子系统。

封锁子系统，执行并发控制。

日至登记子系统，用以执行恢复任务。

<br/>

7.　在操作系统中也有并发控制问题，为什么数据库管理系统还要并发控制机制？

操作系统提供的封锁机制和数据库管理系统的封锁机制在封锁对象、封锁对象的状态、封锁的粒度、及封锁的类型上存在很大的差别，操作系统的封锁机制不能直接应用在数据库管理系统中，数据库管理系统必须重新设计，来满足复杂的封锁需求。

<br/>

8.　试比较数据库管理系统与操作系统的封锁技术。

| | 操作系统 | 数据库管理系统 |
| - | - | - |
| **封锁对象** | 单一，系统资源（包括 CPU、设备、表格等） | 多样，数据库中各种数据对象（包括用户数据、索引、数据字典等） |
| **封锁对象的状态** | 静态、确定；各种封锁对象在封锁表中占有一项；封锁对象数是不变的 | 动态，不确定；封锁对象动态改变、常常在执行前不能确定；一个封锁对象只有当封锁时才在封锁表中占据一项 |
| **封锁的粒度** | 不变，由于封锁对象单一、固定，封锁粒度不会改变 | 可变，封锁可加到或大或小的数据单位上，封锁粒度可以是整个数据库、记录、字段 |
| **封锁的类型** | 单一，排他锁 | 多样，一般有共享锁（S Lock）、排他锁（X Lock）、其他类型的封锁，随系统而异 |

<br/>

9.　数据库管理系统中为什么要设置系统缓冲区？

一是它把数据存储层以上各系统成分和实际的外存设备隔离，外村设备的变更不会影响其他系统成分，使关系数据库管理系统具有设备独立性。二是提高存取效率。

<br/>

10.　数据库中要存储和管理的数据内容包括哪些方面

数据描述，即数据的外模式、模式、内模式。

数据本身。

数据之间的联系。

存取路径。

<br/>

11.　请给出缓冲区管理中的一个淘汰算法，并上机实现（提示：首先需要设计缓冲区的数据结构，然后写出算法）。

略。

<br/>

12.　请写出对一个文件按某个属性的排序算法（设该文件的记录是定长的），并上机实现。若要按多个属性排序，能否写出改进的算法？

略。

<br/>

13.　请给出 B+ 树文件的创建和维护（增、删、改）算法并上机实现（提示：设 B+ 树的叶结点上仅存放索引项（码值，TID），首先要设计索引项，B 树叶页和非叶页的数据结构，然后写出算法）。

略。

<br/>

### 第 13 章　数据库技术发展概述
1.　请阅读本章参考文献。

略。

<br/>

2.　试述数据库技术的发展过程。数据库技术发展的特点是什么？

发展过程：

依据数据模型的进展，数据库技术可以相应地分为三个阶段，即第一代的网状、层次数据库系统，第二代的关系数据库系统，新一代的数据库大家族。

层次模型和网状模型都是格式化模型。它们从体系结构、数据库语言到数据存储管理均具有共同特诊，是第一代数据库系统。

支持关系数据模型的关系数据库系统是第二代数据库系统。

新一代数据库系统以更丰富多样的数据模型和数据管理功能为特征，满足广泛复杂的新应用要求。

特点：

数据模型的发展。

数据库技术与相关技术相结合。

面向应用领域的数据库新技术。

<br/>

3.　试述数据模型在数据库系统发展中的作用和地位。

作用：数据模型是数据库系统的核心和基础。
地位：数据库的发展集中表现在数据模型的发展上。

<br/>

4.　请用实例阐述数据库技术与其他计算机技术相结合的成果。

数据库技术与分布处理技术相结合，出现了分布式数据库系统；

数据库技术与并行处理技术相结合，出现了并行数据库系统；

数据库技术与人工智能技术相结合，出现了演绎数据库、知识库、主动数据库系统；

数据库技术与多媒体技术相结合，出现了多媒体数据库系统；

数据库技术与模糊技术相结合，出现了模糊数据库系统等；

数据库技术与移动通信技术相结合，出现了移动数据库系统等；

数据库技术与 Web 技术相结合，出现了 Web 数据库等。

<br/>

### 第 14 章　大数据管理
1.　请阅读本章参考文献。

略。

<br/>

2.　什么是大数据，试述大数据的基本特征。

大数据是指无法在可容忍的时间内用现有 IT 技术和软硬件工具对其进行感知、获取、管理、处理、服务的数据集合。

<dl>
    大数据的基本特征：
    <dd>大数据的首要特征是数据量巨大，而且在持续、急剧地膨胀。</dd>
    <dd>大数据异构的数据类型、不同的数据表示和语义解释多样。</dd>
    <dd>大数据的快变性也称为实时性，一方面指数据到达的速度很快，另一方而指能够进行处理的时间很短，或者要求响应速度很快，即实时响应。</dd>
    <dd>大数据的价值是潜在的、巨大的。大数据不仅具有经济价值和产业价值，还具有科学价值。这是大数据最重要的特点，也是大数据的魅力所在。</dd>
</dl>

<br/>

3.　分析传统 RDBMS 在大数据时代的局限性。

关系数据库在大数据时代丧失了互联网搜索这个机会，其主要原因是关系数据库管理系统（并行数据库）的扩展性遇到了前所未有的障碍，不能胜任大数据分析的需求，关系数据管理模型追求的是高度的一致性和正确性，面向超大数据的分析需求。

<br/>

4.　分析传统 RDBMS 的哪些技术应该在非关系数据管理系统中继承和发展。

传统 RDBMS 的一致性和 ACID 特性在非关系数据管理系统中继续和发展。

<br/>

5.　什么 NoSQL，试述 NoSQL 系统在大数据库发展中的作用。

NoSQL 是以互联网大数据应用为背景发展起来的分布式数据管理系统。NoSQL 有两种解释：一种是 Non-Relational，即非关系数据库；另一种是 Not Only SQL，即数据管理技术不仅仅是 SQL。NoSQL 系统支持的数据模型通常分为：Key-Value 模型、BigTable 模型、文档（document）模型、图（Graph）模型 4 种类型。

NoSQL 系统为了提高存储能力和并发读写能力采用了极其简单的数据模型，支持简单的查询操作，而将复杂操作留给应用层实现。该系统对数据进行划分，对各个数据分区进行备份，以应对结点可能的失败，提高
系统可用性；通过大量结点的并行处理获得高性能，采用的是横向扩展的方式。

<br/>

6.　什么是 NewSQL，查询相关资料，分析 NewSQL 是如何融合 NoSQL 和 RDBMS 两者的优势的。

NewSQL 系统是融合了 NoSQL 系统和传统数据库事务管理功能的新型数据库系统。

NewSQL 将 SQL 和 NoSQL 的优势结合起来，充分利用计算机硬件的新技术、新结构，研究与开发了
若干创新的实现技术。

<br/>

7.　描述 MapReduce 的计算过程。分析 MapReduce 技术作为大数据分析平台的优势和不足。

MapReduce 技术主要应用于大规模廉价集群上的大数据并行处理。MapReduce 以 key/value 的分布式存储系统为基础，通过元数据集中存储、数据以 chunk 为单位分布存储和数据 chunk 冗余复制来保证其高可用性。

优势：MapReduce 是一种并行编程模型。其处理模式以离线式批量处理为主。

不足：基于 MapReduce 的应用软件较少，许多数据分析功能需要用户自行开发，从而导致使用成本增加。程序与数据缺乏独立性。在同等硬件条件下，MapReduce 的性能远低于并行数据库。MapReduce 处理连接的性能尤其不尽如人意。

<br/>

### 第 15 章　内存数据库系统
1.　内存数据库和磁盘数据库有什么区别？

在内存数据库中。内存作为常规的数据存储准备，磁盘是数据的永久存储及后备存储设备。内存数据库的数据组织、存储访问模型、查询处理模型都针对内存特性进行了优化设计，内存数据被处理直接访问。

在磁盘数据库中，磁盘是常规的数据存储设备，磁盘阵列或磁带机是数据的后备存储设备，内存作为磁盘数据库的缓存使用。磁盘数据库的数据组织、存储访问模型、查询处理模型都是面向磁盘访问特性而设计的，磁盘数据通过缓冲区被处理器访问，查询优化的核心是减少磁盘的输入/输出。

<br/>

2.　内存数据库的特点有哪些？

高吞吐率和低访问延迟。

并行处理能力。

硬件相关性。

<br/>

3.　试述内存数据库和硬件的相关性。哪些硬件技术影响内存数据库的性能？

内存数据库的性能受硬件特性的直接影响。计算机硬件技术的发展主要体现在高端计算设备和存储设备上，如多核处理器、众核协处理器（Many Integrated Core，MIC）、通用 GPU、PCM 存储（Phase Change Memory，相变存储）、固态硬盘（Solid State Disk，SSD）存储等。这些计算能力和存储性能的提升有助于内存吞吐率需求的提升（众核技术）、提高内存持久存储能力（PCM 技术）或为内存提供二级存储（SSD 技术）。硬件技术在多核及众核处理器、高性能存储和高速网络等方面的发展为内存数据库提供了高并行处理、高性能存储访问以及高速连通的硬件平台。内存数据库的设计应该充分考虑并有效利用由新硬件技术带来的功能扩展和性能提高。

大容量内存、flash、PCM 存储、多核 CPU、众核处理器、高性能网络传输等硬件技术的发展为内存数据库提供了良好的平台，直接影响到内存数据库的性能。

<br/>

4.　大数据时代对内存数据库提出了哪些挑战？

大数据的特点有：数据量大、类型繁多、价值密度低、速度快时效高。

随着大数据时代的到来，未来众核协处理器、通用计算图形处理器（General Purpose Graphic Unit，GPGPU）等新的高性能计算平台进入数据库领域，同时也对内存数据库提出了更多挑战。

查询处理与优化，主要针对大数据数据量大和类型繁多的特点。page-coloring 优化技术对于数据持久
驻留内存的内存数据库来说，较大的弱局部性数据集往往需要预先分配较大的内存地址范围，而较少的 page color 对应的地址范围较小，难以满足大数据集存储的要求。

实时分析处理性能，主要针对大数据速度快时效高的特点。内存数据摆脱了 I/O 延迟之后，内存访问速度得到极大的提升，在新兴的非易失性内存，如 PCM 等技术支持下，内存计算和更新的速度进一步提升。事务型内存数据库的一个技术发展趋势是将事务串行化，简化并发控制机制，提高内存数据库代码执行效率，使串行处理性能能够满足高吞吐性能需求。分析型内存数据库则将计算最大化并行，以提高多核处理器的并行计算效率，提高应对内存大数据实时分析处理的性能需求。

并发与恢复技术，主要针对大数据数据量大和价值密度低的特点。通过对大数据表的共享扫描减少并
发查询时独立大表扫描所产生的 cache 缺失，主要通过查询分组以及查询操作符批处理技术实现共享扫描基础上的高并发查询处理。

<br/>

### 第 16 章　数据仓库与联机分析处理技术
1.　数据仓库的 4 个基本特征是什么？

数据仓库的数据是面向主题的。
数据仓库中的数据是面向主题进行组织的。主题是一个抽象的概念，是在较高层次上将企业信息系统中的数据综合、归类并进行分析利用的抽象。面向主题的数据组织方式是根据分析要求将数据组织成一个完备的分析领域，即主题域。

数据仓库的数据是集成的。操作型数据与分析型数据之间差别甚大，数据仓库的数据是从原有分散的数据库数据中抽取来的，因此数据在进入数据仓库之前必然要经过加工与集成，统一与综合。

数据仓库的数据是不可更新的。OLTP 数据库中的数据经过抽取、清洗、转换、装载存放到数据仓库中（这一过程简记为 ECTL）。一旦数据存放到数据仓库中，数据就不可再更新了。

数据仓库的数据是随时间变化的。数据仓库的数据是随时间的变化不断变化的，这一特征表现在以下三方面。第一，数据仓库随时间变化不断增加新的数据内容。第二，数据仓库随时间变化不断删去旧的数据内容。第三，数据仓库数据的标识码都包含时间项，以标明数据的历史时期。

<br/>

2.　操作型数据和分析型数据的主要区别是什么？

| 操作型数据 | 分析型数据 |
| - | - |
| 细节的 | 综合的或提炼的 |
| 在存取瞬间是准确的 | 代表过去的数据 |
| 可更新 | 不可更新 |
| 操作需求事先可知道 | 操作需求事先不知道 |
| 生命周期符合软件开发生命周期（SDLC） | 完全不同的生命周期 |
| 对性能要求高 | 对性能要求宽松 |
| 一个时刻操作一元组 | 一个时刻操作一集合 |
| 事物驱动 | 分析驱动 |
| 面向应用 | 面向分析 |
| 一次操作数据量小 | 一次操作数据量大 |
| 支持日常操作 | 支持管理决策需求 |

<br/>

3.　在基于关系数据库的联机分析处理实现中，举例说明如何利用关系数据库的二维表来表达多维概念。

略。

<br/>

4.　数据挖掘和传统的分析方法的主要不同是什么？

数据挖掘是从大量数据中发现并提取隐藏在内的、人们事先不知道的但又可能有用的信息和知识的一种新技术。

传统的分析方法通常是在某个假设的前提下，通过数据查询和分析来验证或否定这个假设。

<br/>

5.　大数据时代传统的数据仓库系统面临哪些问题？如何应对这些挑战？

传统的数据仓库系统面临的问题：

数据移动代价过高。

不能快速适应变化。

为了应对这些挑战，以较低的成本高效地支持大数据分析，新型的数据仓库解决方案需具备的几个重要特性：

| 特性 | 简要说明 |
| - | - |
| 高度可扩展 | 横向大规模可扩展，大规模并行处理 |
| 高性能 | 快速响应复杂查询与分析 |
| 高度容错性 | 查询失败时，只需重做部分工作 |
| 支持异构环境 | 对硬件平台一致性要求不高，适应能力强 |
| 较低的分析延迟 | 业务需求变化时，能快速反应 |
| 易用且开放接口 | 既能方便查询，又能处理复杂分析 |
| 较低成本 | 较高的性价比 |
| 向下兼容性 | 支持传统的 BI 工具 |